"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[443],{5162:(e,n,a)=>{a.d(n,{Z:()=>o});var t=a(7294),r=a(6010);const i={tabItem:"tabItem_Ymn6"};function o(e){let{children:n,hidden:a,className:o}=e;return t.createElement("div",{role:"tabpanel",className:(0,r.Z)(i.tabItem,o),hidden:a},n)}},4866:(e,n,a)=>{a.d(n,{Z:()=>T});var t=a(7462),r=a(7294),i=a(6010),o=a(2466),s=a(6550),l=a(1980),c=a(7392),u=a(12);function m(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:n,label:a,attributes:t,default:r}}=e;return{value:n,label:a,attributes:t,default:r}}))}function p(e){const{values:n,children:a}=e;return(0,r.useMemo)((()=>{const e=n??m(a);return function(e){const n=(0,c.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,a])}function h(e){let{value:n,tabValues:a}=e;return a.some((e=>e.value===n))}function d(e){let{queryString:n=!1,groupId:a}=e;const t=(0,s.k6)(),i=function(e){let{queryString:n=!1,groupId:a}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:n,groupId:a});return[(0,l._X)(i),(0,r.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(t.location.search);n.set(i,e),t.replace({...t.location,search:n.toString()})}),[i,t])]}function g(e){const{defaultValue:n,queryString:a=!1,groupId:t}=e,i=p(e),[o,s]=(0,r.useState)((()=>function(e){let{defaultValue:n,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!h({value:n,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const t=a.find((e=>e.default))??a[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:i}))),[l,c]=d({queryString:a,groupId:t}),[m,g]=function(e){let{groupId:n}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(n),[t,i]=(0,u.Nk)(a);return[t,(0,r.useCallback)((e=>{a&&i.set(e)}),[a,i])]}({groupId:t}),f=(()=>{const e=l??m;return h({value:e,tabValues:i})?e:null})();(0,r.useLayoutEffect)((()=>{f&&s(f)}),[f]);return{selectedValue:o,selectValue:(0,r.useCallback)((e=>{if(!h({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);s(e),c(e),g(e)}),[c,g,i]),tabValues:i}}var f=a(2389);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(e){let{className:n,block:a,selectedValue:s,selectValue:l,tabValues:c}=e;const u=[],{blockElementScrollPositionUntilNextRender:m}=(0,o.o5)(),p=e=>{const n=e.currentTarget,a=u.indexOf(n),t=c[a].value;t!==s&&(m(n),l(t))},h=e=>{let n=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const a=u.indexOf(e.currentTarget)+1;n=u[a]??u[0];break}case"ArrowLeft":{const a=u.indexOf(e.currentTarget)-1;n=u[a]??u[u.length-1];break}}n?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":a},n)},c.map((e=>{let{value:n,label:a,attributes:o}=e;return r.createElement("li",(0,t.Z)({role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,key:n,ref:e=>u.push(e),onKeyDown:h,onClick:p},o,{className:(0,i.Z)("tabs__item",v.tabItem,o?.className,{"tabs__item--active":s===n})}),a??n)})))}function y(e){let{lazy:n,children:a,selectedValue:t}=e;const i=(Array.isArray(a)?a:[a]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===t));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},i.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==t}))))}function k(e){const n=g(e);return r.createElement("div",{className:(0,i.Z)("tabs-container",v.tabList)},r.createElement(b,(0,t.Z)({},e,n)),r.createElement(y,(0,t.Z)({},e,n)))}function T(e){const n=(0,f.Z)();return r.createElement(k,(0,t.Z)({key:String(n)},e))}},8146:(e,n,a)=>{a.d(n,{Z:()=>o});var t=a(3764),r=a(7294);const i=new class{initialized=!1;initMonaco(e){this.initialized||(console.log("initMonaco"),this.initialized=!0,this.monaco=e,this.setMonacoTypescriptDefaults(),this.addExtraTsLib({types:"\n/// <reference types=\"node\" />\ndeclare module \"packages/env/src/lib/env.interface\" {\n    export type ValueEncodingType = 'base64' | 'base64url' | 'hex' | 'url';\n    export enum EnvLogLevel {\n        DEBUG = \"debug\",\n        LOG = \"log\",\n        WARN = \"warn\",\n        ERROR = \"error\"\n    }\n    export interface ParsingOptions {\n        /**\n         * The prefix of your environment variables.         * Provide this option if you want to validate that the environment variable name starts with the provided prefix.\n         */\n        variableNamePrefix?: string;\n        /**\n         * Whether to ignore the casing of your environment variable names.         * @default false\n         */\n        variableNameIgnoreCasing?: boolean;\n        /**\n         * Whether to trim the value of your environment variables.         * @default false\n         */\n        valueTrim?: boolean;\n        /**\n         * The encoding of your environment variables.         * Provide this option if you want to decode the value of your environment variables.         * Possible values are 'base64', 'base64url', 'hex' and 'url'.         */\n        valueEncoding?: ValueEncodingType;\n        /**\n         * Whether to remove the value of your environment variables after parsing.         * Provide this option if you want to remove the value of your environment variables after parsing.         * This can improve the security of your application.         * @default false\n         */\n        valueRemoveAfterParse?: boolean;\n    }\n    export interface BooleanParsingptions extends ParsingOptions {\n        /**\n         * The values (strings) that are considered as true.\n         * @default true, 1, yes, y, on, enabled, enable, ok, okay\n         */\n        booleanTrueValues?: string[];\n        /**\n         * The values (strings) that are considered as false.\n         * @default false, 0, no, n, off, disabled, disable\n         */\n        booleanFalseValues?: string[];\n    }\n    export interface StringParsingOptions extends ParsingOptions {\n        /**\n         * The minimum length of the string.\n         */\n        stringMinLength?: number;\n        /**\n         * The maximum length of the string.\n         */\n        stringMaxLength?: number;\n        /**\n         * The pattern of the string.\n         */\n        stringPattern?: RegExp | string;\n    }\n    export interface EnumParsingOptions extends ParsingOptions {\n        /**\n         * Whether to ignore the casing of the enum values.\n         */\n        enumIgnoreCasing?: boolean;\n    }\n    export interface NumberParsingOptions extends ParsingOptions {\n        /**\n         * Whether the number must be an integer.\n         */\n        numberIsInteger?: boolean;\n        /**\n         * The minimum value of the number.\n         */\n        numberMinimum?: number;\n        /**\n         * The maximum value of the number.\n         */\n        numberMaximum?: number;\n        /**\n         * The minimum value of the number (exclusive).\n         */\n        numberExclusiveMinimum?: number;\n        /**\n         * The maximum value of the number (exclusive).\n         */\n        numberExclusiveMaximum?: number;\n    }\n    export interface JsonParsingOptions extends ParsingOptions {\n        /**\n         * The minimum number of properties of the JSON object.\n         */\n        jsonMinProperties?: number;\n        /**\n         * The maximum number of properties of the JSON object.\n         */\n        jsonMaxProperties?: number;\n        /**\n         * The required properties of the JSON object.\n         */\n        jsonRequired?: string[];\n        /**\n         * Whether to allow additional properties of the JSON object.\n         */\n        jsonAdditionalProperties?: boolean;\n    }\n    export interface ArrayParsingOptions extends ParsingOptions {\n        /**\n         * The separator of the array.\n         */\n        arraySeparator?: string;\n        /**\n         * The minimum length of the array.\n         */\n        arrayMinLength?: number;\n        /**\n         * The maximum length of the array.\n         */\n        arrayMaxLength?: number;\n        /**\n         * Whether to remove the duplicate items of the array.\n         */\n        arrayUniqueItems?: boolean;\n    }\n}\ndeclare module \"packages/env/src/lib/env-configuration.interface\" {\n    import { EnvLogLevel, ValueEncodingType } from \"packages/env/src/lib/env.interface\";\n    export interface EnvConfiguration<RuntimeEnvironment extends {\n        [key: string]: string;\n    } = {}> {\n        /** Whether to enable logging. */\n        debug: boolean;\n        /** The log levels that are enabled. */\n        logLevels: EnvLogLevel[];\n        /** The runtime of your application */\n        runtime?: RuntimeEnvironment[keyof RuntimeEnvironment] | string;\n        /** The possible runtimes of your application.         * Provide this option if you want to validate that the runtime is one of the provided runtimes.\n         */\n        runtimes?: RuntimeEnvironment;\n        /** The process environment (probably only useful for testing).         * Provide this option if you want to use a custom process environment.\n         * @default process.env\n         */\n        processEnv: NodeJS.ProcessEnv;\n        /** Whether to throw an error if the runtime is missing.         * Provide this option if you want to throw an error if the runtime is missing.\n         * @default false\n         */\n        throwOnMissingRuntime: boolean;\n        /**\n         * The prefix of your environment variables.         * Provide this option if you want to validate that the environment variable name starts with the provided prefix.\n         */\n        variableNamePrefix: string;\n        /**\n         * Whether to ignore the casing of your environment variable names.\n         * @default false\n         */\n        variableNameIgnoreCasing: boolean;\n        /**\n         * Whether to trim the value of your environment variables.\n         * @default false\n         */\n        valueTrim: boolean;\n        /**\n         * The encoding of your environment variables.         * Provide this option if you want to decode the value of your environment variables.         * Possible values are 'base64', 'base64url', 'hex' and 'url'.         */\n        valueEncoding?: ValueEncodingType;\n        /**\n         * Whether to remove the value of your environment variables after parsing.         * Provide this option if you want to remove the value of your environment variables after parsing.         * This can improve the security of your application.\n         * @default false\n         */\n        valueRemoveAfterParse: boolean;\n        /**\n         * The values (strings) that are considered as true.\n         * @default true, 1, yes, y, on, enabled, enable, ok, okay\n         */\n        booleanTrueValues: string[];\n        /**\n         * The values (strings) that are considered as false.\n         * @default false, 0, no, n, off, disabled, disable\n         */\n        booleanFalseValues: string[];\n        /**\n         * The minimum length of the string.\n         */\n        stringMinLength?: number;\n        /**\n         * The maximum length of the string.\n         */\n        stringMaxLength?: number;\n        /**\n         * The pattern of the string.\n         */\n        stringPattern?: RegExp | string;\n        /**\n         * Whether to ignore the casing of the enum values.\n         */\n        enumIgnoreCasing: boolean;\n        /**\n         * The minimum value of the number.\n         */\n        numberMinimum?: number;\n        /**\n         * The maximum value of the number.\n         */\n        numberMaximum?: number;\n        /**\n         * Whether the number must be an integer.\n         */\n        numberIsInteger: boolean;\n        /**\n         * The minimum value of the number (exclusive).\n         */\n        numberExclusiveMinimum?: number;\n        /**\n         * The maximum value of the number (exclusive).\n         */\n        numberExclusiveMaximum?: number;\n        /**\n         * The required properties of the JSON object.\n         */\n        jsonRequired: string[];\n        /**\n         * The minimum number of properties of the JSON object.\n         */\n        jsonMinProperties?: number;\n        /**\n         * The maximum number of properties of the JSON object.\n         */\n        jsonMaxProperties?: number;\n        /**\n         * Whether to allow additional properties of the JSON object.\n         */\n        jsonAdditionalProperties: boolean;\n        /**\n         * The separator of the array.\n         * @default ,\n         */\n        arraySeparator: string;\n        /**\n         * The minimum length of the array.\n         */\n        arrayMinLength?: number;\n        /**\n         * The maximum length of the array.\n         */\n        arrayMaxLength?: number;\n        /**\n         * Whether to ensure that the array has unique items.\n         * @default false\n         */\n        arrayUniqueItems: boolean;\n    }\n}\ndeclare module \"packages/env/src/lib/env-error\" {\n    /**\n     * Parsing error thrown when a value cannot be parsed from an environment variable.\n     */\n    export class EnvParsingError extends Error {\n        readonly variableName: string;\n        readonly value: unknown;\n        constructor(message: string, context: {\n            variableName: string;\n            value: unknown;\n        });\n    }\n    /**\n     * Validation error thrown when an environment variable value does not fulfill the validation criteria.\n     */\n    export class EnvValidationError extends Error {\n        readonly variableName: string;\n        readonly value: unknown;\n        constructor(message: string, context: {\n            variableName: string;\n            value: unknown;\n        });\n    }\n    /**\n     * Validation error thrown when an invalid input is provided to the method.\n     */\n    export class EnvInputValidationError extends Error {\n        readonly parameter: string;\n        readonly value: unknown;\n        constructor(message: string, context: {\n            parameter: string;\n            value: unknown;\n        });\n    }\n}\ndeclare module \"packages/env/src/lib/env-logger\" {\n    import { EnvConfiguration } from \"packages/env/src/lib/env-configuration.interface\";\n    export class EnvLogger {\n        private readonly config?;\n        constructor(config?: Partial<Pick<EnvConfiguration, 'debug' | 'logLevels'>>);\n        debug(message: string): void;\n        log(message: string): void;\n        warn(message: string): void;\n        error(message: string): void;\n    }\n}\ndeclare module \"packages/env/src/lib/env.utils\" {\n    import { EnvConfiguration } from \"packages/env/src/lib/env-configuration.interface\";\n    /**\n     * Parses an environment variable from the process environment.\n     * @param variableName The name of the environment variable to parse.\n     * @param config The parsing configuration to use.\n     * @returns The parsed environment variable value as a string, or undefined if the variable is not set.\n     */\n    export function parseEnvironmentVariable<RuntimeEnvironment extends {\n        [key: string]: string;\n    }>(variableName: string, config: Pick<EnvConfiguration<RuntimeEnvironment>, 'processEnv' | 'variableNamePrefix' | 'variableNameIgnoreCasing' | 'valueTrim' | 'valueEncoding' | 'valueRemoveAfterParse'>): string | undefined;\n    /**\n     * Parses a value to a boolean.\n     * @param value The value to parse.\n     * @param config The parsing configuration to use.\n     * @returns The parsed boolean value, or undefined if the value could not be parsed.\n     */\n    export function parseBooleanValue<RuntimeEnvironment extends {\n        [key: string]: string;\n    }>(value: unknown, config: Pick<EnvConfiguration<RuntimeEnvironment>, 'booleanTrueValues' | 'booleanFalseValues'>): boolean | undefined;\n    export function parseNumberValue(value: unknown): number | undefined;\n    export function validateNumberValue<RuntimeEnvironment extends {\n        [key: string]: string;\n    }>(value: number | undefined, config: Pick<EnvConfiguration<RuntimeEnvironment>, 'numberMinimum' | 'numberMaximum' | 'numberIsInteger' | 'numberExclusiveMinimum' | 'numberExclusiveMaximum'>): true | string;\n    export function validateStringValue<RuntimeEnvironment extends {\n        [key: string]: string;\n    }>(value: string | undefined, config: Pick<EnvConfiguration<RuntimeEnvironment>, 'stringMinLength' | 'stringMaxLength' | 'stringPattern'>): true | string;\n    export function parseEnumValue<TEnum extends {\n        [key: string]: string;\n    }, RuntimeEnvironment extends {\n        [key: string]: string;\n    }>(enumType: TEnum, value: unknown, config: Pick<EnvConfiguration<RuntimeEnvironment>, 'enumIgnoreCasing'>): TEnum[keyof TEnum] | undefined;\n    /**\n     * Parses a value to an array of strings.\n     * @param value The value to parse.\n     * @param config The parsing configuration to use.\n     * @returns The parsed array of strings, or undefined if the value could not be parsed.\n     */\n    export function parseArrayValue<RuntimeEnvironment extends {\n        [key: string]: string;\n    }>(value: unknown, config: Pick<EnvConfiguration<RuntimeEnvironment>, 'arraySeparator'>): string[] | undefined;\n    export function validateArrayValue<RuntimeEnvironment extends {\n        [key: string]: string;\n    }>(value: string[] | undefined, config: Pick<EnvConfiguration<RuntimeEnvironment>, 'arrayMinLength' | 'arrayMaxLength' | 'arrayUniqueItems'>): true | string;\n    export function isNotNullish<T>(el: T | null | undefined): el is T;\n    /**\n     * Assigns the properties of object2 to object1, but only if they are not undefined\n     * @param target Object to assign to\n     * @param source Object to assign from\n     * @returns The modified target object with the assigned properties\n     */\n    export function assignPartialObject<T extends object>(target: T, source: Partial<T> | undefined | null): T;\n}\ndeclare module \"packages/env/src/lib/env\" {\n    import { EnvConfiguration } from \"packages/env/src/lib/env-configuration.interface\";\n    import { EnvLogger } from \"packages/env/src/lib/env-logger\";\n    import { ArrayParsingOptions, BooleanParsingptions, EnumParsingOptions, JsonParsingOptions, NumberParsingOptions, StringParsingOptions } from \"packages/env/src/lib/env.interface\";\n    export class SkylineEnv<RuntimeEnvironment extends {\n        [key: string]: string;\n    }> {\n        private readonly config;\n        private readonly logger;\n        constructor(config?: Partial<EnvConfiguration<RuntimeEnvironment>> & {\n            logger?: EnvLogger;\n        });\n        /**\n         * Get the runtime environment.\n         * @returns The runtime environment or \"undefined\" if no runtime environment is set.\n         */\n        get runtime(): RuntimeEnvironment[keyof RuntimeEnvironment] | undefined;\n        /**\n         * Parse an environment variable as a boolean.\n         * @param variableName Name of the environment variable to parse\n         * @param options Optional parsing options\n         * @returns The parsed boolean value, or undefined if the variable is not set.\n         */\n        parseBoolean(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: boolean | (() => boolean);\n        }> & {\n            default: boolean | (() => boolean);\n        } & BooleanParsingptions): boolean;\n        parseBoolean(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: boolean | (() => boolean);\n        }> & {\n            default?: boolean | (() => boolean);\n        } & BooleanParsingptions): boolean | undefined;\n        /**\n         * Parse an environment variable as an array of booleans.\n         * @param variableName Name of the environment variable to parse\n         * @param options Optional parsing options\n         * @returns The parsed boolean array, or undefined if the variable is not set.\n         */\n        parseBooleanArray(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: boolean[] | (() => boolean[]);\n        }> & {\n            default: boolean[] | (() => boolean[]);\n        } & BooleanParsingptions & ArrayParsingOptions): boolean[];\n        parseBooleanArray(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: boolean[] | (() => boolean[]);\n        }> & {\n            default?: boolean[] | (() => boolean[]);\n        } & BooleanParsingptions & ArrayParsingOptions): boolean[] | undefined;\n        /**\n         * Parse an environment variable as a string.\n         * @param variableName Name of the environment variable to parse\n         * @param options Optional parsing options\n         * @returns The parsed string value, or undefined if the variable is not set.\n         */\n        parseString(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: string | (() => string);\n        }> & {\n            default: string | (() => string);\n        } & StringParsingOptions): string;\n        parseString(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: string | (() => string);\n        }> & {\n            default?: string | (() => string);\n        } & StringParsingOptions): string | undefined;\n        /**\n         * Parse an environment variable as an array of strings.\n         * @param variableName Name of the environment variable to parse\n         * @param options Optional parsing options\n         * @returns The parsed string array, or undefined if the variable is not set.\n         */\n        parseStringArray(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: string[] | (() => string[]);\n        }> & {\n            default: string[] | (() => string[]);\n        } & StringParsingOptions & ArrayParsingOptions): string[];\n        parseStringArray(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: string[] | (() => string[]);\n        }> & {\n            default?: string[] | (() => string[]);\n        } & StringParsingOptions & ArrayParsingOptions): string[] | undefined;\n        /**\n         * Parse an environment variable as an enum.\n         * @param variableName Name of the environment variable to parse\n         * @param enumType Enum type to parse the environment variable as\n         * @param options Optional parsing options\n         * @returns The parsed enum value, or undefined if the variable is not set.\n         */\n        parseEnum<TEnum extends {\n            [key: string]: string;\n        }>(variableName: string, enumType: TEnum, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: TEnum[keyof TEnum] | (() => TEnum[keyof TEnum]);\n        }> & EnumParsingOptions & {\n            default: TEnum[keyof TEnum] | (() => TEnum[keyof TEnum]);\n        }): TEnum[keyof TEnum];\n        parseEnum<TEnum extends {\n            [key: string]: string;\n        }>(variableName: string, enumType: TEnum, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: TEnum[keyof TEnum] | (() => TEnum[keyof TEnum]);\n        }> & EnumParsingOptions & {\n            default?: TEnum[keyof TEnum] | (() => TEnum[keyof TEnum]);\n        }): TEnum[keyof TEnum] | undefined;\n        /**\n         * Parse an environment variable as an enum.\n         * @param variableName Name of the environment variable to parse\n         * @param enumType Enum type to parse the environment variable as\n         * @param options Optional parsing options\n         */\n        parseEnumArray<TEnum extends {\n            [key: string]: string;\n        }>(variableName: string, enumType: TEnum, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: Array<TEnum[keyof TEnum]> | (() => Array<TEnum[keyof TEnum]>);\n        }> & EnumParsingOptions & ArrayParsingOptions & {\n            default: Array<TEnum[keyof TEnum]> | (() => Array<TEnum[keyof TEnum]>);\n        }): Array<TEnum[keyof TEnum]>;\n        parseEnumArray<TEnum extends {\n            [key: string]: string;\n        }>(variableName: string, enumType: TEnum, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: Array<TEnum[keyof TEnum]> | (() => Array<TEnum[keyof TEnum]>);\n        }> & EnumParsingOptions & ArrayParsingOptions & {\n            default?: Array<TEnum[keyof TEnum]> | (() => Array<TEnum[keyof TEnum]>);\n        }): Array<TEnum[keyof TEnum]> | undefined;\n        /**\n         * Parse an environment variable as a number.\n         * @param variableName Name of the environment variable to parse\n         * @param options Optional parsing options\n         * @returns The parsed number value, or undefined if the variable is not set.\n         */\n        parseNumber(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: number | (() => number);\n        }> & {\n            default: number | (() => number);\n        } & NumberParsingOptions): number;\n        parseNumber(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: number | (() => number);\n        }> & {\n            default?: number | (() => number);\n        } & NumberParsingOptions): number | undefined;\n        /**\n         * Parse an environment variable as an array of numbers.\n         * @param variableName Name of the environment variable to parse\n         * @param options Optional parsing options\n         * @returns The parsed number array, or undefined if the variable is not set.\n         */\n        parseNumberArray(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: number[] | (() => number[]);\n        }> & {\n            default: number[] | (() => number[]);\n        } & NumberParsingOptions & ArrayParsingOptions): number[];\n        parseNumberArray(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: number[] | (() => number[]);\n        }> & {\n            default?: number[] | (() => number[]);\n        } & NumberParsingOptions & ArrayParsingOptions): number[] | undefined;\n        /**\n         * Parse an environment variable as a JSON object.\n         * @param variableName Name of the environment variable to parse\n         * @param options Optional parsing options\n         */\n        parseJSON<TJson extends object>(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: TJson | (() => TJson);\n        }> & {\n            default: TJson | (() => TJson);\n        } & JsonParsingOptions): TJson;\n        parseJSON<TJson extends object>(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: TJson | (() => TJson);\n        }> & {\n            default?: TJson | (() => TJson);\n        } & JsonParsingOptions): TJson | undefined;\n    }\n}\ndeclare module \"@skyline-js/env\" {\n    export * from \"packages/env/src/lib/env\";\n    export * from \"packages/env/src/lib/env-error\";\n    export * from \"packages/env/src/lib/env.interface\";\n    export * from \"packages/env/src/lib/env-configuration.interface\";\n}\n\n"}),this.addExtraTsLib({types:'\ndeclare module "packages/cache/src/lib/interface/cache-key.type" {\n    export type CacheKey = string | number | BigInt | boolean;\n}\ndeclare module "packages/cache/src/lib/cache-error" {\n    import type { CacheKey } from "packages/cache/src/lib/interface/cache-key.type";\n    export class CacheInconsistencyError extends Error {\n        readonly key: CacheKey;\n        readonly namespace: string;\n        readonly value: string;\n        readonly cachedValue: string;\n        constructor(message: string, context: {\n            key: CacheKey;\n            namespace: string;\n            value: string;\n            cachedValue: string;\n        });\n    }\n    export class CacheInputValidationError extends Error {\n        readonly parameter: string;\n        readonly value: unknown;\n        constructor(message: string, context: {\n            parameter: string;\n            value: unknown;\n        });\n    }\n    export class CacheStorageEngineError extends Error {\n        readonly operation: string;\n        readonly storageEninge: string;\n        constructor(message: string, context: {\n            operation: string;\n            storageEninge: string;\n        });\n    }\n}\ndeclare module "packages/cache/src/lib/logger/cache-logger.interface" {\n    import type { CacheKey } from "packages/cache/src/lib/interface/cache-key.type";\n    export interface CacheLoggerConfiguration {\n        enabled: boolean;\n        logLevels: CacheLogLevel[];\n    }\n    export enum CacheLogLevel {\n        LOG = "log",\n        WARN = "warn",\n        ERROR = "error"\n    }\n    export enum CacheMessageInfoType {\n        CACHE_STALE = "cache_stale",\n        UNKNOWN_ERROR = "unknown_error",\n        CACHE_INCONSISTENCY = "cache_inconsistency",\n        STORAGE_ENGINE_ERROR = "storage_engine_error",\n        INPUT_VALIDATION_ERROR = "input_validation_error"\n    }\n    interface CacheMessageInfo {\n        type: CacheMessageInfoType;\n    }\n    export interface CacheStaleMessageInfo extends CacheMessageInfo {\n        type: CacheMessageInfoType.CACHE_STALE;\n        key: CacheKey;\n        namespace: string;\n        durationMs: number;\n        staleThresholdMs: number;\n    }\n    export interface CacheUnknownErrorMessageInfo extends CacheMessageInfo {\n        type: CacheMessageInfoType.UNKNOWN_ERROR;\n        error: unknown;\n    }\n    export interface CacheInconsistencyMessageInfo extends CacheMessageInfo {\n        type: CacheMessageInfoType.CACHE_INCONSISTENCY;\n        key: CacheKey;\n        namespace: string;\n        value: string;\n        cachedValue: string;\n    }\n    export interface CacheInputValidationErrorMessageInfo extends CacheMessageInfo {\n        type: CacheMessageInfoType.INPUT_VALIDATION_ERROR;\n        parameter: string;\n        value: unknown;\n    }\n    export type CacheMessageInfoUnion = CacheStaleMessageInfo | CacheUnknownErrorMessageInfo | CacheInconsistencyMessageInfo | CacheInputValidationErrorMessageInfo;\n}\ndeclare module "packages/cache/src/lib/interface/cache-configuration.interface" {\n    import type { CacheLogLevel } from "packages/cache/src/lib/logger/cache-logger.interface";\n    export interface CacheConfiguration {\n        /**\n         * The prefix for all keys of this cache instance.         * Defaults to "cache"\n         */\n        cachePrefix: string;\n        /**\n         * Optional version for the cache. This can be used to invalidate the cache when the data structure has changed.         * Defaults to "undefined"\n         */\n        cacheVersion?: string;\n        /**\n         * Whether to force cache skips. This is useful for local development and CI environments to validate every cache.         * Defaults to "false"\n         */\n        forceCacheSkips: boolean;\n        /**\n         * Default expiration time in ms for cache entries.         * Defaults to 24 hours\n         */\n        defaultCacheExpirationMs: number;\n        /**\n         * Threshold in ms to consider data stale, causing the data to be discarded instead of writing it to the cache.         * Defaults to 2 seconds\n         */\n        staleThresholdMs: number;\n        /**\n         * Whether to disable namespaces on cache inconsistency.         * Defaults to "false"\n         */\n        disableNamespaces: boolean;\n        /**\n         * The prefix for the key to store disabled namespaces information in storage.         * Defaults to "disabled-namespaces"\n         */\n        disabledNamespacesKeyPrefix: string;\n        /**\n         * The interval in ms to check synchronize disabled namespaces from storage.         * Defaults to 30 seconds\n         */\n        disabledNamespacesSyncIntervalMs: number;\n        /**\n         * The expiration time in ms for disabling a namespace.         * Defaults to 24 hours\n         */\n        disabledNamespaceExpirationMs: number;\n        /**\n         * The value written to a key to block it.         * Defaults to "blocked"\n         */\n        cacheKeyBlockedValue: string;\n        /**\n         * The expiration time in ms for blocking a key.         * Defaults to 10 seconds\n         */\n        blockedKeyExpirationMs: number;\n        /**\n         * Whether to throw if an error occurrs.         * Defaults to "false"\n         */\n        throwOnError: boolean;\n        /**\n         * Whether logging is enabled.         * Defaults to "true"\n         */\n        loggingEnabled: boolean;\n        /**\n         * The log levels to log.         * Defaults to all available log levels\n         */\n        logLevels: CacheLogLevel[];\n        /**\n         * The seed for the random number generator\n         * Defaults to "cache-rnd-seed"\n         */\n        randomGeneratorSeed: string;\n    }\n}\ndeclare module "packages/cache/src/lib/interface/cache-statistics.interface" {\n    export interface CacheStatistics {\n        /** Number of cache hits */\n        numCacheHits: number;\n        /** Number of cache misses */\n        numCacheMisses: number;\n        /** Number of cache skips */\n        numCacheSkips: number;\n        /** Number of cache skips due to disabled namespaces */\n        numCacheDisabledNamespaceSkips: number;\n        /** Number of cache invalidations */\n        numCacheInvalidations: number;\n        /** Number of cache consistency checks */\n        numCacheConsistencyChecks: number;\n        /** Number of cache inconsistencies */\n        numCacheInconsistencies: number;\n        /** Number of unknown cache errors */\n        numCacheErrors: number;\n    }\n}\ndeclare module "packages/cache/src/lib/cache.utils" {\n    export function isNotNullish<T>(el: T | null | undefined): el is T;\n    export function isNullish<T>(value?: T | null | undefined): value is null | undefined;\n    export function extractMessageFromError(error: unknown): string | undefined;\n    export function extractStackFromError(error: unknown): string | undefined;\n    /**\n     * Get a random number generator based on a seed string\n     * @param seed The seed string\n     * @returns A random number generator that produces a number between 0 and 1\n     */\n    export function getRandomNumberGenerator(seed?: string): () => number;\n}\ndeclare module "packages/cache/src/lib/logger/cache-logger" {\n    import { CacheLoggerConfiguration, CacheMessageInfoUnion } from "packages/cache/src/lib/logger/cache-logger.interface";\n    export class CacheLogger {\n        private readonly config?;\n        constructor(config?: Partial<CacheLoggerConfiguration>);\n        log(message: string, info: CacheMessageInfoUnion): void;\n        warn(message: string, info: CacheMessageInfoUnion): void;\n        error(message: string, info: CacheMessageInfoUnion): void;\n    }\n}\ndeclare module "packages/cache/src/lib/storage-engine/cache-storage-engine" {\n    /**\n     * The interface for a cache storage engine.\n     */\n    export abstract class CacheStorageEngine {\n        /**\n         * Get a value from the cache\n         * @param key The key to get the value for\n         * @returns The value or "undefined" if not found\n         */\n        abstract get(key: string): Promise<string | undefined>;\n        abstract getMany(keys: string[]): Promise<Array<string | undefined>>;\n        abstract getKeysByPattern(pattern: string): Promise<string[]>;\n        /**\n         * Set a value for a key.\n         * @param key The key to set the value for.\n         * @param value The value to set.\n         * @param opts.expiresIn The time in milliseconds after which the value should expire.\n         */\n        abstract set(key: string, value: string, opts?: {\n            expiresIn?: number;\n        }): Promise<unknown>;\n        abstract setMany(inputs: {\n            key: string;\n            value: string;\n            expiresIn?: number;\n        }[]): Promise<unknown>;\n        /**\n         * Set a value for a key if it does not exist yet.\n         * @param key The key to set the value for.\n         * @param value The value to set.\n         * @param opts.expiresIn The time in milliseconds after which the value should expire.\n         */\n        abstract setIfNotExist(key: string, value: string, opts?: {\n            expiresIn?: number;\n        }): Promise<unknown>;\n        abstract setManyIfNotExist(inputs: {\n            key: string;\n            value: string;\n            expiresIn?: number;\n        }[]): Promise<unknown>;\n    }\n}\ndeclare module "packages/cache/src/lib/storage-engine/in-memory-cache-storage-engine" {\n    import { CacheStorageEngine } from "packages/cache/src/lib/storage-engine/cache-storage-engine";\n    interface InMemoryCacheStorageEngineConfiguration {\n        periodicCleanup?: boolean;\n        cleanupIntervalMs: number;\n    }\n    /**\n     * A cache storage engine that stores the cache in memory.\n     */\n    export class InMemoryCacheStorageEngine extends CacheStorageEngine {\n        private readonly config;\n        private readonly cache;\n        constructor(config?: Partial<InMemoryCacheStorageEngineConfiguration>);\n        /**\n         * Get a value from the cache\n         * @param key The key to get the value for\n         * @returns The value or "undefined" if not found\n         */\n        get(key: string): Promise<string | undefined>;\n        getMany(keys: string[]): Promise<Array<string | undefined>>;\n        ttl(key: string): Promise<number | undefined>;\n        /**\n         * Get all keys matching a pattern. The pattern can contain "*" as a wildcard, which matches any number of characters (including zero)\n         * @param pattern The pattern to match\n         * @returns The keys matching the pattern\n         */\n        getKeysByPattern(_pattern: string): Promise<string[]>;\n        /**\n         * Set a value for a key.\n         * @param key The key to set the value for.\n         * @param value The value to set.\n         * @param opts.expiresIn The time in milliseconds after which the value should expire.\n         */\n        set(key: string, value: string, opts?: {\n            expiresIn?: number;\n        }): Promise<void>;\n        setMany(inputs: {\n            key: string;\n            value: string;\n            expiresIn?: number;\n        }[]): Promise<void>;\n        setIfNotExist(key: string, value: string, opts?: {\n            expiresIn?: number;\n        }): Promise<void>;\n        setManyIfNotExist(inputs: {\n            key: string;\n            value: string;\n            expiresIn?: number;\n        }[]): Promise<void>;\n    }\n}\ndeclare module "packages/cache/src/lib/cache" {\n    import { CacheConfiguration } from "packages/cache/src/lib/interface/cache-configuration.interface";\n    import { CacheStatistics } from "packages/cache/src/lib/interface/cache-statistics.interface";\n    import { CacheKey } from "packages/cache/src/lib/interface/cache-key.type";\n    import { CacheLogger } from "packages/cache/src/lib/logger/cache-logger";\n    import { CacheStorageEngine } from "packages/cache/src/lib/storage-engine/cache-storage-engine";\n    /**\n     * ### SkylineCache\n     *\n     * TODO: Good documentation\n     * Results of source queries can be cached by their primary key. A typical caching operation consists of the "namespace" (e.g. "user") and the primary key (e.g. the user ID: "123").\n     * Aggregate results can also be cached. For example, all user IDs for the organization. In this case, the namespace would be "organization-user-ids" and the primary key would be "organizationId".\n     * To avoid timing bugs, the cache invalidation blocks the key for a short period of time. Writing to a cache key is only possible if the key does not exist.\n     * The cache key invalidation should happen at the end of the source transaction but before the transaction is committed.\n     * A transaction gets the source from one consistent state to another consistent state. If we would invalidate the caches after the transaction is committed, we might return an inconsistent state because some caches might be invalidated and some might not.\n     * If a transaction is long-running, invalidating the cache key at the start of the transaction might be insufficient as the blocking period might run out before the transaction is committed.\n     * Therefore, we "collect" the cache keys that need to be invalidated during the transaction and invalidate them right before the transaction is committed.\n     *\n     * # Cache consistency observability\n     * It is close to impossible to write bug-free cache invalidation code. Therefore, we need to be able to observe the cache consistency and react to inconsistencies.\n     * The cache consistency observability is implemented by using the following strategy:\n     * The developer can configure a percentage of cache reads that should be skipped. This value should be 100% when a cache is first introduced. This way no cached values are used and every cached value will be checked for correctness.\n     * As the "get" / "getMany" function returns an artifical cache miss, the application goes on and fetches the data from the source. Afterwards, the fetched values will be written to cache via the "setIfNotExist" / "setManyIfNotExist" functions.\n     * These functions check if the key already exists. If so, the given value will be compared with the cached value. If the values are not equal, an cache inconsistency is detected and an exception will be thrown.\n     * When no cache inconsistencies are observed, the percentage value can be gradually lowered so that we enjoy the benefits of the caching with increasing confidence in the consistency of the cache. The value should never be 0%, otherwise\n     * we have no way of observing cache inconsistencies.\n     *\n     * Potential causes for cache inconsistencies:\n     *   - Developer forgets to invalidate the cache (deterministic inconsistency)\n     *   - Transaction committing takes longer than the cache key blocking period (timing dependent inconsistency)\n     *   - The staleness check passes but the writing to cache takes longer than blocking period (timing dependent inconsistency)\n     */\n    export class SkylineCache {\n        private readonly config;\n        private readonly storage;\n        private readonly logger;\n        private readonly random;\n        /** Whether the cache skipping feature is disabled */\n        private cacheSkippingDisabled;\n        /** Disabled namespaces (e.g., due to detected cache inconsistency) */\n        private disabledNamespaces;\n        /** Cache statistics */\n        private readonly statistics;\n        constructor({ config, storage, logger, }?: {\n            config?: Partial<CacheConfiguration>;\n            storage?: CacheStorageEngine;\n            logger?: CacheLogger | typeof CacheLogger;\n        });\n        /**\n         * Get the storage key for a given namespace and key.\n         * Takes the cache prefix and cache version into account if configured.\n         * @param namespace The namespace.\n         * @param key The key.\n         * @returns The storage key.\n         */\n        private getStorageKey;\n        /**\n         * Get a value from the cache.\n         * @param namespace The namespace of the cached value (e.g. "user").\n         * @param key The key of the cached value (e.g. the user ID: "123")\n         * @param validator A validator function to validate the cached value.\n         * @param opts.skip A probability between 0 and 1 whether the cache read should be skipped.\n         *                  This is used to detect cache inconsistencies.\n         *                  If the cache read is skipped, the function artifically returns "undefined" (= cache miss).\n         *                  Defaults to 0 (0% of cache reads are skipped).\n         * @returns The cached value if it exists and is valid, "undefined" otherwise.\n         */\n        get<T>(namespace: string, key: CacheKey, validator: (input: unknown) => asserts input is T, opts?: {\n            skip?: number;\n        }): Promise<{\n            value: T | undefined;\n            skipped: boolean;\n        }>;\n        /**\n         * Get multiple values from the cache.\n         * @param namespace The namespace of the cached values (e.g. "user").\n         * @param keys The keys of the cached values (e.g. the user IDs: ["123", "456"])\n         * @param validator A validator function to validate each cached value.\n         * @param opts.skip A probability between 0 and 1 whether the cache read should be skipped.\n         *                  This is used to detect cache inconsistencies.\n         *                  If the cache read is skipped, the function artifically returns "undefined" (= cache miss).\n         *                  Defaults to 0 (0% of cache reads are skipped).\n         * @returns An array containing the cached values if they exist and are valid, "undefined" otherwise.\n         *          The order of the array is the same as the order of the input keys.\n         *          The length of the array is the same as the length of the input keys.\n         */\n        getMany<T>(namespace: string, keys: ReadonlyArray<CacheKey>, validator: (input: unknown) => asserts input is T, opts?: {\n            skip?: number;\n        }): Promise<{\n            values: Array<T | undefined>;\n            skipped: boolean;\n        }>;\n        /**\n         * Set a cache value in the cache if it does not already exist.\n         * This operation does nothing if the value already exists or is blocked.\n         * @param namespace The namespace of the cached value (e.g. "user").\n         * @param keyFunc A function to calculate the key of the cached value (e.g. the user ID: "123").\n         * @param value  The value to cache.\n         * @param opts.fetchedAt The timestamp when the value was fetched from the source.\n         *                       Used to determine if the value is stale (time difference is above the stale threshold).\n         *                       Timestamp is in UNIX milliseconds.\n         * @param opts.expiresIn The expiration of the cached value in milliseconds.\n         * @param opts.validate  Whether the cache value should be validated.\n         *                       This is used to detect cache inconsistencies.\n         *                       Defaults to false (no cache values are validated).\n         */\n        setIfNotExist<T>(namespace: string, keyFunc: (input: T) => CacheKey, value: T, { fetchedAt, expiresIn, ...opts }: {\n            fetchedAt: number;\n            expiresIn?: number;\n            validate?: boolean;\n        }): Promise<void>;\n        /**\n         * Set multiple cache values in the cache if they do not already exist.\n         * @param namespace The namespace of the cached values (e.g. "user").\n         * @param keyFunc A function to calculate the key of the cached value (e.g. the user ID: "123").\n         * @param values The values to cache.\n         * @param opts.fetchedAt The timestamp when the value was fetched from the source. Used to determine if the value is stale (time difference is above the stale threshold). Timestamp is in UNIX milliseconds.\n         * @param opts.expiresIn The expiration of the cached value in milliseconds.\n         * @param opts.validate  Whether the cache value should be validated.\n         *                       This is used to detect cache inconsistencies.\n         *                       Defaults to false (no cache values are validated).\n         */\n        setManyIfNotExist<T>(namespace: string, keyFunc: (input: T) => CacheKey, values: T[], { fetchedAt, expiresIn, ...opts }: {\n            fetchedAt: number;\n            expiresIn?: number;\n            validate?: boolean;\n        }): Promise<void>;\n        /**\n         * Invalidate a cache value in the cache. Blocks the key for a short period of time to avoid timing bugs.\n         * @param namespace The namespace of the cached value (e.g. "user").\n         * @param key The key of the cached value (e.g. the user ID: "123").\n         * @param opts.expiresIn The expiration of the blocked state in milliseconds.\n         */\n        invalidate(namespace: string, key: CacheKey, { expiresIn }?: {\n            expiresIn?: number;\n        }): Promise<void>;\n        /**\n         * Invalidate multiple cache values in the cache. Blocks each key for a short period of time to avoid timing bugs.\n         * @param keys Array of namespace and key pairs to invalidate.\n         * @param opts.expiresIn The expiration of the blocked state in milliseconds.\n         */\n        invalidateMany(keys: ReadonlyArray<{\n            namespace: string;\n            key: CacheKey;\n        }>, { expiresIn }?: {\n            expiresIn?: number;\n        }): Promise<void>;\n        /**\n         * Private/ internal function to check the cache consistency.\n         * @param valueStr The value to check.\n         * @param cachedValueStr The cached value to check.\n         * @param context The context in which the check is performed.\n         */\n        private checkCacheConsistency;\n        /**\n         * Private/ internal function to handle errors that occurred while handling the cache.\n         * Handle an error that occurred while handling the cache.\n         * @param error The error that occurred.\n         * @param context The context in which the error occurred.\n         */\n        private handleError;\n        /**\n         * Dump the entire contents of the cache.\n         * This should only be used for debugging purposes.\n         */\n        dumpCache(): Promise<{\n            [key: string]: string | undefined;\n        }>;\n        /**\n         * Get caching statistics.\n         * @returns The caching statistics.\n         */\n        getStatistics(): CacheStatistics;\n        /**\n         * Reset caching statistics.\n         */\n        resetStatistics(): void;\n        /**\n         * Enables the cache skipping feature. This restore the default behavior of cache skips.          * This function only needs to be called if cache skips have been disabled in the first place.\n         */\n        enableCacheSkipping(): void;\n        /**\n         * Disable the cache skipping feature.          * This is useful for local development to see how the application behaves with full cache hits.          * This is equivalent to setting skip: 0 for all cache read operations.          * This option takes precedence over forceCacheSkips.\n         */\n        disableCacheSkipping(): void;\n        /**\n         * Private/ internal function to check if a namespace is disabled.\n         * @param namespace The namespace to check.\n         * @returns True if the namespace is disabled, false otherwise.\n         */\n        private isNamespaceDisabled;\n        /**\n         * Private/ internal function to disable a namespace.\n         * @param namespace The namespace to disable.\n         */\n        private disableNamespace;\n        /**\n         * Synchronize the disabled namespaces.\n         * This function is periodically called to synchronize the disabled namespaces from storage.\n         */\n        synchronizeDisabledNamespaces(): Promise<void>;\n        /**\n         * Get the disabled namespaces.\n         * The namespaces are periodically synchronized from storage.\n         * Therefore, only the namespaces that have been synchronized are returned.\n         * @returns The disabled namespaces.\n         */\n        getDisabledNamespaces(): string[];\n        /**\n         * Set disabled namespaces.\n         * Use this method if you want to manually handle namespace disabling.\n         * @param namespaces The namespaces to disable.\n         */\n        setDisabledNamespaces(...namespaces: string[]): void;\n        /**\n         * Remove all disabled namespaces.\n         * Use this method if you want to manually handle namespace disabling.\n         */\n        clearDisabledNamespaces(): void;\n    }\n}\ndeclare module "packages/cache/src/lib/storage-engine/redis-cache-storage-engine.interface" {\n    /**\n     * ioredis client interface\n     */\n    export interface IoRedisClient {\n        multi(options: {\n            pipeline: false;\n        }): Promise<\'OK\'>;\n        multi(): IoRedisChainableCommander;\n        multi(options: {\n            pipeline: true;\n        }): IoRedisChainableCommander;\n        multi(commands?: unknown[][]): IoRedisChainableCommander;\n        get(key: string): Promise<string | null | undefined>;\n        mget(keys: string[]): Promise<Array<string | null | undefined>>;\n        keys(pattern: string): Promise<string[]>;\n    }\n    type Callback<T = any> = (err?: Error | null, result?: T) => void;\n    interface IoRedisChainableCommander {\n        exec(callback?: Callback<[error: Error | null, result: unknown][] | null>): Promise<[error: Error | null, result: unknown][] | null>;\n        set(key: string, value: string): IoRedisChainableCommander;\n        set(key: string, value: string, secondsToken: \'EX\', seconds: number | string): IoRedisChainableCommander;\n        set(key: string, value: string, nx: \'NX\'): IoRedisChainableCommander;\n        set(key: string, value: string, secondsToken: \'EX\', seconds: number | string, nx: \'NX\'): IoRedisChainableCommander;\n    }\n    /**\n     * node-redis client interface\n     */\n    export interface NodeRedisClient {\n        multi: () => NodeRedisClientMultiCommand;\n        get(key: string): Promise<string | null | undefined>;\n        mGet(keys: string[]): Promise<Array<string | null | undefined>>;\n        keys(pattern: string): Promise<string[]>;\n    }\n    type MaximumOneOf<T, K extends keyof T = keyof T> = K extends keyof T ? {\n        [P in K]?: T[K];\n    } & Partial<Record<Exclude<keyof T, K>, never>> : never;\n    type SetTTL = MaximumOneOf<{\n        EX: number;\n        PX: number;\n        EXAT: number;\n        PXAT: number;\n        KEEPTTL: true;\n    }>;\n    type SetGuards = MaximumOneOf<{\n        NX: true;\n        XX: true;\n    }>;\n    interface SetCommonOptions {\n        GET?: true;\n    }\n    type NodeRedisSetOptions = SetTTL & SetGuards & SetCommonOptions;\n    interface NodeRedisClientMultiCommand {\n        exec(): Promise<Array<any>>;\n        set(key: string, value: string, options: NodeRedisSetOptions): NodeRedisClientMultiCommand;\n    }\n    /**\n     * Unified redis client interface\n     */\n    export interface RedisClient {\n        multi(): RedisClientChainable;\n        get(key: string): Promise<string | null | undefined>;\n        mget(keys: string[]): Promise<Array<string | null | undefined>>;\n        keys(pattern: string): Promise<string[]>;\n    }\n    interface RedisClientChainable {\n        exec(): Promise<unknown>;\n        set(key: string, value: string, options: {\n            ex?: number;\n            nx?: boolean;\n        }): RedisClientChainable;\n    }\n}\ndeclare module "packages/cache/src/lib/storage-engine/redis-cache-storage-engine.utils" {\n    import { IoRedisClient, NodeRedisClient, RedisClient } from "packages/cache/src/lib/storage-engine/redis-cache-storage-engine.interface";\n    export function getRedisClientFromNodeOrIoRedisClient(client: IoRedisClient | NodeRedisClient): RedisClient;\n    export function getRedisClientFromNodeRedisClient(client: NodeRedisClient): RedisClient;\n    export function getRedisClientFromIoRedisClient(client: IoRedisClient): RedisClient;\n}\ndeclare module "packages/cache/src/lib/storage-engine/redis-cache-storage-engine" {\n    import { CacheStorageEngine } from "packages/cache/src/lib/storage-engine/cache-storage-engine";\n    import { IoRedisClient, NodeRedisClient } from "packages/cache/src/lib/storage-engine/redis-cache-storage-engine.interface";\n    /**\n     * A cache storage engine that stores the cache in Redis.\n     */\n    export class RedisCacheStorageEngine extends CacheStorageEngine {\n        private readonly redis;\n        constructor({ redis }: {\n            redis: IoRedisClient | NodeRedisClient;\n        });\n        get(key: string): Promise<string | undefined>;\n        getMany(keys: string[]): Promise<Array<string | undefined>>;\n        getKeysByPattern(pattern: string): Promise<string[]>;\n        setMany(inputs: {\n            key: string;\n            value: string;\n            expiresIn: number;\n        }[]): Promise<unknown>;\n        set(key: string, value: string, opts: {\n            expiresIn: number;\n        }): Promise<unknown>;\n        setIfNotExist(key: string, value: string, opts: {\n            expiresIn: number;\n        }): Promise<unknown>;\n        setManyIfNotExist(inputs: {\n            key: string;\n            value: string;\n            expiresIn: number;\n        }[]): Promise<unknown>;\n    }\n}\ndeclare module "@skyline-js/cache" {\n    export * from "packages/cache/src/lib/cache";\n    export * from "packages/cache/src/lib/cache-error";\n    export * from "packages/cache/src/lib/interface/cache-key.type";\n    export * from "packages/cache/src/lib/interface/cache-statistics.interface";\n    export * from "packages/cache/src/lib/interface/cache-configuration.interface";\n    export * from "packages/cache/src/lib/logger/cache-logger";\n    export * from "packages/cache/src/lib/logger/cache-logger.interface";\n    export * from "packages/cache/src/lib/storage-engine/cache-storage-engine";\n    export * from "packages/cache/src/lib/storage-engine/redis-cache-storage-engine";\n    export * from "packages/cache/src/lib/storage-engine/in-memory-cache-storage-engine";\n}\n\n'}),this.addExtraTsLib({types:'\ndeclare module "packages/translate/src/lib/translate.interface" {\n    const isTranslationKey: unique symbol;\n    export type TranslationKey = string & {\n        [isTranslationKey]: true;\n    };\n    export type TranslationParameter = string | number | BigInt | undefined;\n    export enum TranslateLogLevel {\n        DEBUG = "DEBUG",\n        LOG = "LOG",\n        WARN = "WARN",\n        ERROR = "ERROR"\n    }\n    export interface TranslationParameters {\n        [key: string]: TranslationParameters | TranslationParameter;\n    }\n    export interface RecursiveStringObject {\n        [key: string]: RecursiveStringObject | string;\n    }\n    export type CastToTranslationKeys<O> = {\n        [P in keyof O]: O[P] extends string ? TranslationKey : CastToTranslationKeys<O[P]>;\n    };\n}\ndeclare module "packages/translate/src/lib/translate-configuration.interface" {\n    import { TranslateLogLevel, TranslationParameters } from "packages/translate/src/lib/translate.interface";\n    export interface TranslateConfiguration {\n        /** The language to translate to. If multiple languages are provided, the first available translation is used */\n        language?: string;\n        /** The language to fallback to if no translations for the selected language are available */\n        fallbackLanguage?: string;\n        /** Whitelist available languages. If a translations object contains a language that is not in this list, an error is thrown */\n        availableLanguages?: {\n            [key: string]: string;\n        } | string[];\n        /** Whether to use fuzzy matching for the language: ignore case, whitespaces, "*" wildcard support, fallback to same language with no culture or another culture */\n        languageFuzzyMatching?: boolean;\n        /** The interpolation pattern, can be a RegExp or an object with prefix and suffix (e.g. { prefix: \'{{\', suffix: \'}}\' }) */\n        interpolation: RegExp | {\n            prefix: string;\n            suffix: string;\n        };\n        /** The parameters to use for interpolation. */\n        params?: TranslationParameters;\n        /** The separator to specify the path to a parameter (e.g. \'user.name\' for { user: { name: \'John\' } }) */\n        paramKeySeparator: string;\n        /**\n         * How to handle missing parameters: \'keep\' (keep the handlebars), \'remove\' (remove the handlebars), \'throw\' (throw an error)\n         * @default \'keep\'\n         */\n        handleMissingParam: \'keep\' | \'remove\' | \'throw\';\n        /**\n         * How to handle missing translations: \'keep\' (keep the translation key), \'remove\' (remove the translation key), \'throw\' (throw an error)\n         */\n        handleMissingTranslation: \'keep\' | \'remove\' | \'throw\';\n        /**\n         * Whether logging is enabled.         * Defaults to "true"\n         */\n        loggingEnabled: boolean;\n        /**\n         * The log levels to log.         * Defaults to all available log levels\n         */\n        logLevels: TranslateLogLevel[];\n    }\n}\ndeclare module "packages/translate/src/lib/util/helper.utils" {\n    /**\n     * Assigns the properties of object2 to object1, but only if they are not undefined\n     * @param target Object to assign to\n     * @param source Object to assign from\n     * @returns The modified target object with the assigned properties\n     */\n    export function assignPartialObject<T extends object>(target: T, source: Partial<T> | undefined | null): T;\n}\ndeclare module "packages/translate/src/lib/util/interpolation.utils" {\n    import { TranslateConfiguration } from "packages/translate/src/lib/translate-configuration.interface";\n    export function substituteInterpolations({ template, config, }: {\n        template: string | undefined;\n        config: TranslateConfiguration;\n    }): string | undefined;\n}\ndeclare module "packages/translate/src/lib/util/translate.utils" {\n    import { TranslateConfiguration } from "packages/translate/src/lib/translate-configuration.interface";\n    import { CastToTranslationKeys, RecursiveStringObject, TranslationKey } from "packages/translate/src/lib/translate.interface";\n    /**\n     * Create a translation keys object with the same structure as the translation object, but with the values replaced by the translation keys\n     * @param translation The translation object\n     * @param parentPaths The parent paths (used for recursion)\n     * @returns The translation keys object\n     */\n    export function getTranslationKeysObject<Translations extends Record<string, RecursiveStringObject>>(translation: RecursiveStringObject, parentPaths?: string[]): CastToTranslationKeys<Translations[keyof Translations]>;\n    export function getTranslationTemplate({ key, config, translations, }: {\n        translations: any;\n        config: TranslateConfiguration;\n        key: TranslationKey | undefined | null;\n    }): string | undefined;\n}\ndeclare module "packages/translate/src/lib/translate" {\n    import { TranslateConfiguration } from "packages/translate/src/lib/translate-configuration.interface";\n    import { CastToTranslationKeys, RecursiveStringObject, TranslationKey } from "packages/translate/src/lib/translate.interface";\n    /**\n     * The SkylineTranslate class\n     */\n    export class SkylineTranslate<Translations extends Record<string, RecursiveStringObject>> {\n        private readonly translations;\n        private readonly config;\n        private keys;\n        constructor(translations: Translations, config?: Partial<TranslateConfiguration>);\n        /**\n         * Get the translation keys object\n         */\n        get key(): CastToTranslationKeys<Translations[keyof Translations]>;\n        /**\n         * Translate a string using the provided translation key and options\n         * @param key The translation key\n         * @param options The translation options\n         * @returns The translated string\n         */\n        translate(key: TranslationKey | undefined | null, options?: Partial<TranslateConfiguration>): string;\n    }\n    /**\n     * Create a SkylineTranslate class with default configuration\n     * @param defaultConfig The default configuration\n     * @returns The SkylineTranslate class with default configuration\n     */\n    export function configureSkylineTranslate(defaultConfig: Partial<TranslateConfiguration>): typeof SkylineTranslate;\n}\ndeclare module "packages/translate/src/lib/translate-logger" {\n    import { TranslateConfiguration } from "packages/translate/src/lib/translate-configuration.interface";\n    export class TranslateLogger {\n        private readonly config?;\n        constructor(config?: Partial<Pick<TranslateConfiguration, \'loggingEnabled\' | \'logLevels\'>>);\n        debug(message: string): void;\n        log(message: string): void;\n        warn(message: string): void;\n        error(message: string): void;\n    }\n}\ndeclare module "packages/translate/src/lib/util/http-request.utils" {\n    /**\n     * Parse HTTP header "Accept-Language" to get the languages accepted by the client.\n     * @param headers The HTTP request\'s headers object or the "Accept-Language" header value\n     * @returns The languages accepted by the client, sorted by q value (highest q value first)\n     */\n    export function parseHttpHeaderAcceptLanguages(headers?: {\n        [key: string]: string | string[];\n    } | string | string[] | null | undefined): string[];\n}\ndeclare module "packages/translate/src/lib/util/browser.utils" {\n    export function getBrowserLanguage(): string | undefined;\n    export function getBrowserCultureLanguage(): string | undefined;\n}\ndeclare module "@skyline-js/translate" {\n    export * from "packages/translate/src/lib/translate";\n    export * from "packages/translate/src/lib/translate-configuration.interface";\n    export * from "packages/translate/src/lib/translate-logger";\n    export { TranslationKey, TranslationParameter, TranslationParameters, } from "packages/translate/src/lib/translate.interface";\n    export { parseHttpHeaderAcceptLanguages } from "packages/translate/src/lib/util/http-request.utils";\n    export { getBrowserLanguage, getBrowserCultureLanguage } from "packages/translate/src/lib/util/browser.utils";\n}\n\n'}))}setMonacoTypescriptDefaults(){this.monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({noSemanticValidation:!1,noSyntaxValidation:!1,diagnosticCodesToIgnore:[1375,2304,2339,2345,2451,2584,2585,2531,6200,1108,2582]}),this.monaco.languages.typescript.typescriptDefaults.setCompilerOptions({target:this.monaco.languages.typescript.ScriptTarget.ES2020,module:this.monaco.languages.typescript.ModuleKind.ESNext,allowNonTsExtensions:!0,noLib:!0}),this.monaco.languages.typescript.typescriptDefaults.setEagerModelSync(!0),this.monaco.languages.typescript.typescriptDefaults.setExtraLibs([])}addExtraTsLib(e){let{filename:n,types:a}=e;if(!this.monaco)throw new Error("MonacoService.addExtraTsLib was called before initialization!");return this.monaco.languages.typescript.typescriptDefaults.addExtraLib(a,n)}};class o extends r.Component{render(){return r.createElement("div",{style:{width:"100%",height:this.props.height??"300px",overflow:"hidden",background:"rgb(30, 30, 30)",borderRadius:"var(--ifm-code-border-radius)"}},r.createElement(t.ZP,{height:"100%",width:"100%",language:"typescript",defaultLanguage:"typescript",theme:"vs-dark",options:{language:"typescript",theme:"vs-dark",contextmenu:!1,fixedOverflowWidgets:!0,lineDecorationsWidth:16,padding:{top:16,bottom:16},scrollbar:{vertical:"auto",handleMouseWheel:!0,alwaysConsumeMouseWheel:!1},minimap:{enabled:!1},folding:!1},defaultValue:this.props.value,onMount:(e,n)=>{i.initMonaco(n)}}))}componentDidMount(){console.log("mounted")}}},1245:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var t=a(7462),r=(a(7294),a(3905)),i=(a(4866),a(5162),a(8146));const o={sidebar_position:2,slug:"environment",label:"Environment"},s="Environment",l={unversionedId:"environment",id:"environment",title:"Environment",description:"This page describes the guiding principles of the Skyline environment approach.",source:"@site/docs/environment.md",sourceDirName:".",slug:"/environment",permalink:"/docs/environment",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,slug:"environment",label:"Environment"},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/docs/introduction"},next:{title:"Caching",permalink:"/docs/caching"}},c={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Example code walkthrough",id:"example-code-walkthrough",level:2},{value:"Sandbox",id:"sandbox",level:2}],m={toc:u},p="wrapper";function h(e){let{components:n,...a}=e;return(0,r.kt)(p,(0,t.Z)({},m,a,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"environment"},"Environment"),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"This page describes the guiding principles of the Skyline environment approach. ",(0,r.kt)("br",null),"\nThe API reference of the ",(0,r.kt)("inlineCode",{parentName:"p"},"@skyline-js/env")," package can be found here: ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/env"},"@skyline-js/env"))),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Even the best CI/CD setup does not prevent your application to crash in production because someone forgot to set ",(0,r.kt)("inlineCode",{parentName:"p"},"SERVER_PRD_DB_TLS_CONNECTION=true"))),(0,r.kt)("p",null,"Environment variable management is not a good conversation topic when attending a social event. Even when you talk to another developer, chances are they just don't care that much about their environment variables.\nEven worse, they might have been responsible for a production downtime due to an environment variable issue and now you just re-traumatized them. As you can see, it is much more appropriate for you to talk about the weather, like everybody else does."),(0,r.kt)("p",null,"Anyways, as you are reading the SkylineJS documentation, I assume you are most likely not attending such an event. Therefore, we will discuss how your environment variable management strategy can ensure maximum type safety, perform runtime validations and provide you with an overall peace of mind."),(0,r.kt)("p",null,"We all have seen code like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"db.connect({\n  host: process.env.DB_HOST || 'localhost',\n  port: process.env.DB_PORT || 5432,\n  useTLS: process.env.DB_TLS === '1' ? true : false,\n  auth: {\n    username: process.env.DB_USER || 'admin',\n    password: process.env.DB_PASSWORD || 'strong_password_with_special_chars_%#!',\n  },\n});\n")),(0,r.kt)("p",null,"And we have all debugged code like that in production because ",(0,r.kt)("inlineCode",{parentName:"p"},"DB_HOST")," is missing the protocol prefix, ",(0,r.kt)("inlineCode",{parentName:"p"},"DB_TLS")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},'"true"')," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},'"1"')," and ",(0,r.kt)("inlineCode",{parentName:"p"},"DB_PASSWORD")," is incorrect because the special characters got url-encoded when the password got pulled from a secrets manager via FTP (yes I know)."),(0,r.kt)("p",null,"To avoid these issues, your environment variable management should be based on the following principles:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Environment variables are parsed and validated by a single module of your codebase. Nobody else touches ",(0,r.kt)("inlineCode",{parentName:"p"},"process.env"),". Everyone else gets their environment variables from this module.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Every environment variable is tested for syntactical correctness during parsing. This ensures that the type and shape of the environment variable is guaranteed to the rest of the application during runtime.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"All non-sensitive environment variables are declared and maintained inside the codebase. There is no value in scattering your different environment configs across multiple ",(0,r.kt)("inlineCode",{parentName:"p"},".env")," files and inside your deployment scripts.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Error handling should be as strict as possible. Each unexpected environment state should lead to a failure of the application. This way you can rollback the application update immediately and prevent it from causing issues in production later on."))),(0,r.kt)("h2",{id:"example-code-walkthrough"},"Example code walkthrough"),(0,r.kt)("p",null,"To demonstrate the implementation of the principles above, we take a look at a basic environment variable parsing using the ",(0,r.kt)("inlineCode",{parentName:"p"},"@skyline-js/env")," package:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { SkylineEnv } from '@skyline-js/env';\n\nconst parser = new SkylineEnv();\n\nexport const env = {\n  api: {\n    host: parser.parseString('SERVER_API_HOST'),\n    port: parser.parseNumber('SERVER_API_PORT'),\n    cors: parser.parseBoolean('SERVER_CORS_ENABLED'),\n  },\n  database: {\n    host: parser.parseString('SERVER_DATABASE_HOST'),\n    port: parser.parseString('SERVER_DATABASE_PORT'),\n  },\n};\n")),(0,r.kt)("p",null,"The rest of the application can now consume the parsed environment variables the same way they would access ",(0,r.kt)("inlineCode",{parentName:"p"},"process.env"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { env } from '@myapp/env';\n\n// ...\n\ndb.connect({\n  host: env.database.host,\n  port: env.database.port,\n});\n\n// ...\n\napi.listen({\n  host: env.api.host,\n  port: env.api.port,\n  enableCors: env.api.cors,\n});\n")),(0,r.kt)("p",null,"This minimal example only follows principle 1 by keeping the environment variable parsing in a single place. Principle 2 is partially covered as the type of each environment variable is validated (string, number, boolean). Let's rewrite the example above:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { SkylineEnv } from '@skyline-js/env';\n\nexport enum RuntimeEnvironment {\n  DEV = 'DEV',\n  CI = 'CI',\n  PRD = 'PRD',\n}\n\nconst parser = new SkylineEnv({\n  runtime: process.env.NODE_ENV,\n  runtimes: RuntimeEnvironment,\n  valueTrim: true,\n});\n\nexport const env = {\n  api: {\n    host: parser.parseString('SERVER_API_HOST', {\n      default: 'http://localhost',\n      CI: 'http://skyline_ci_database',\n      PRD: 'https://skyline_prd_database',\n      stringPattern: /https?:\\/\\/.+/,\n    }),\n    port: parser.parseNumber('SERVER_API_PORT', {\n      default: 3000,\n      numberIsInteger: true,\n    }),\n    cors: parser.parseBoolean('SERVER_CORS_ENABLED', {\n      default: false,\n      PRD: true,\n    }),\n  },\n  database: {\n    host: parser.parseString('SERVER_DATABASE_HOST', {\n      default: 'localhost',\n      CI: 'skyline_ci_database',\n      PRD: 'skyline_prd_database',\n    }),\n    port: parser.parseString('SERVER_DATABASE_PORT', {\n      default: 5432,\n      numberIsInteger: true,\n    }),\n    password: parser.parseString('SERVER_DATABASE_PASSWORD', {\n      default: 'password123',\n      minLength: 6,\n      valueRemoveAfterParse: true,\n    }),\n  },\n};\n")),(0,r.kt)("p",null,"Ah, this is much better. The most striking difference to the previous implementation is the usage of the runtime environments feature of ",(0,r.kt)("inlineCode",{parentName:"p"},"@skyline-js/env"),". You can define an enum of the available runtime environments for your application, e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"DEV")," (development), ",(0,r.kt)("inlineCode",{parentName:"p"},"CI")," (continuous integration) and ",(0,r.kt)("inlineCode",{parentName:"p"},"PRD")," (production). For each runtime environment, a value can be specified that is used as a fallback if no environment variable has been provided. In the example above, the ",(0,r.kt)("inlineCode",{parentName:"p"},"env.api.host")," value is set to the value of the ",(0,r.kt)("inlineCode",{parentName:"p"},"SERVER_API_HOST")," environment variable but falls back to ",(0,r.kt)("inlineCode",{parentName:"p"},"http://localhost")," in DEV, ",(0,r.kt)("inlineCode",{parentName:"p"},"http://skyline_ci_database")," in CI and to ",(0,r.kt)("inlineCode",{parentName:"p"},"https://skyline_prd_database")," in PRD. Note that the value for the DEV runtime environment is provided via the ",(0,r.kt)("inlineCode",{parentName:"p"},"default")," property. This ensures that the environment variable always has a value, which is reflected in its type not including ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),", which is the case without the ",(0,r.kt)("inlineCode",{parentName:"p"},"default")," property being set."),(0,r.kt)("p",null,"This approach for handling different runtime environments allows the developer to quickly look up all possible values for an environment variable without having to go through ",(0,r.kt)("inlineCode",{parentName:"p"},".env")," files or CI environment settings. For most non-sensitive environment variables, the runtime environment fallbacks should be sufficient to configure the value properly and greatly improves the developer experience regarding the introduction of new environment variables and the debugging process."),(0,r.kt)("p",null,"Furthermore, the example above shows off the validation features of the ",(0,r.kt)("inlineCode",{parentName:"p"},"@skyline-js/env")," package. They are used to ensure that certain environment variable values are integers (e.g., for the API port) or match a certain regex (http or https protocol present for the API host)."),(0,r.kt)("h2",{id:"sandbox"},"Sandbox"),(0,r.kt)(i.Z,{height:"200px",value:"import { SkylineEnv } from '@skyline-js/env';\n\nconst env = new SkylineEnv();\n\n\n\n\n\n\n",mdxType:"MonacoEditor"}," "))}h.isMDXComponent=!0}}]);