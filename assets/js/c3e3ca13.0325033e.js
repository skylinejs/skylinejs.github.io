"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[72],{8146:(e,n,a)=>{a.d(n,{Z:()=>r});var t=a(3764),s=a(7294);const i=new class{initialized=!1;initMonaco(e){this.initialized||(this.initialized=!0,this.monaco=e,this.setMonacoTypescriptDefaults(),this.addExtraTsLib({types:"\n/// <reference types=\"node\" />\ndeclare module \"packages/env/src/lib/env.interface\" {\n    export type ValueEncodingType = 'base64' | 'base64url' | 'hex' | 'url';\n    export enum EnvLogLevel {\n        DEBUG = \"debug\",\n        LOG = \"log\",\n        WARN = \"warn\",\n        ERROR = \"error\"\n    }\n    export interface ParsingOptions {\n        /**\n         * The prefix of your environment variables.         * Provide this option if you want to validate that the environment variable name starts with the provided prefix.\n         */\n        variableNamePrefix?: string;\n        /**\n         * Whether to ignore the casing of your environment variable names.         * @default false\n         */\n        variableNameIgnoreCasing?: boolean;\n        /**\n         * Whether to trim the value of your environment variables.         * @default false\n         */\n        valueTrim?: boolean;\n        /**\n         * The encoding of your environment variables.         * Provide this option if you want to decode the value of your environment variables.         * Possible values are 'base64', 'base64url', 'hex' and 'url'.         */\n        valueEncoding?: ValueEncodingType;\n        /**\n         * Whether to remove the value of your environment variables after parsing.         * Provide this option if you want to remove the value of your environment variables after parsing.         * This can improve the security of your application.         * @default false\n         */\n        valueRemoveAfterParse?: boolean;\n    }\n    export interface BooleanParsingptions extends ParsingOptions {\n        /**\n         * The values (strings) that are considered as true.\n         * @default true, 1, yes, y, on, enabled, enable, ok, okay\n         */\n        booleanTrueValues?: string[];\n        /**\n         * The values (strings) that are considered as false.\n         * @default false, 0, no, n, off, disabled, disable\n         */\n        booleanFalseValues?: string[];\n    }\n    export interface StringParsingOptions extends ParsingOptions {\n        /**\n         * The minimum length of the string.\n         */\n        stringMinLength?: number;\n        /**\n         * The maximum length of the string.\n         */\n        stringMaxLength?: number;\n        /**\n         * The pattern of the string.\n         */\n        stringPattern?: RegExp | string;\n    }\n    export interface EnumParsingOptions extends ParsingOptions {\n        /**\n         * Whether to ignore the casing of the enum values.\n         */\n        enumIgnoreCasing?: boolean;\n    }\n    export interface NumberParsingOptions extends ParsingOptions {\n        /**\n         * Whether the number must be an integer.\n         */\n        numberIsInteger?: boolean;\n        /**\n         * The minimum value of the number.\n         */\n        numberMinimum?: number;\n        /**\n         * The maximum value of the number.\n         */\n        numberMaximum?: number;\n        /**\n         * The minimum value of the number (exclusive).\n         */\n        numberExclusiveMinimum?: number;\n        /**\n         * The maximum value of the number (exclusive).\n         */\n        numberExclusiveMaximum?: number;\n    }\n    export interface JsonParsingOptions extends ParsingOptions {\n        /**\n         * The minimum number of properties of the JSON object.\n         */\n        jsonMinProperties?: number;\n        /**\n         * The maximum number of properties of the JSON object.\n         */\n        jsonMaxProperties?: number;\n        /**\n         * The required properties of the JSON object.\n         */\n        jsonRequired?: string[];\n        /**\n         * Whether to allow additional properties of the JSON object.\n         */\n        jsonAdditionalProperties?: boolean;\n    }\n    export interface ArrayParsingOptions extends ParsingOptions {\n        /**\n         * The separator of the array.\n         */\n        arraySeparator?: string;\n        /**\n         * The minimum length of the array.\n         */\n        arrayMinLength?: number;\n        /**\n         * The maximum length of the array.\n         */\n        arrayMaxLength?: number;\n        /**\n         * Whether to remove the duplicate items of the array.\n         */\n        arrayUniqueItems?: boolean;\n    }\n}\ndeclare module \"packages/env/src/lib/env-configuration.interface\" {\n    import { EnvLogLevel, ValueEncodingType } from \"packages/env/src/lib/env.interface\";\n    export interface EnvConfiguration<RuntimeEnvironment extends {\n        [key: string]: string;\n    } = {}> {\n        /** Whether to enable logging. */\n        debug: boolean;\n        /** The log levels that are enabled. */\n        logLevels: EnvLogLevel[];\n        /** The runtime of your application */\n        runtime?: RuntimeEnvironment[keyof RuntimeEnvironment] | string;\n        /** The possible runtimes of your application.         * Provide this option if you want to validate that the runtime is one of the provided runtimes.\n         */\n        runtimes?: RuntimeEnvironment;\n        /** The process environment (probably only useful for testing).         * Provide this option if you want to use a custom process environment.\n         * @default process.env\n         */\n        processEnv: NodeJS.ProcessEnv;\n        /** Whether to throw an error if the runtime is missing.         * Provide this option if you want to throw an error if the runtime is missing.\n         * @default false\n         */\n        throwOnMissingRuntime: boolean;\n        /**\n         * The prefix of your environment variables.         * Provide this option if you want to validate that the environment variable name starts with the provided prefix.\n         */\n        variableNamePrefix: string;\n        /**\n         * Whether to ignore the casing of your environment variable names.\n         * @default false\n         */\n        variableNameIgnoreCasing: boolean;\n        /**\n         * Whether to trim the value of your environment variables.\n         * @default false\n         */\n        valueTrim: boolean;\n        /**\n         * The encoding of your environment variables.         * Provide this option if you want to decode the value of your environment variables.         * Possible values are 'base64', 'base64url', 'hex' and 'url'.         */\n        valueEncoding?: ValueEncodingType;\n        /**\n         * Whether to remove the value of your environment variables after parsing.         * Provide this option if you want to remove the value of your environment variables after parsing.         * This can improve the security of your application.\n         * @default false\n         */\n        valueRemoveAfterParse: boolean;\n        /**\n         * The values (strings) that are considered as true.\n         * @default true, 1, yes, y, on, enabled, enable, ok, okay\n         */\n        booleanTrueValues: string[];\n        /**\n         * The values (strings) that are considered as false.\n         * @default false, 0, no, n, off, disabled, disable\n         */\n        booleanFalseValues: string[];\n        /**\n         * The minimum length of the string.\n         */\n        stringMinLength?: number;\n        /**\n         * The maximum length of the string.\n         */\n        stringMaxLength?: number;\n        /**\n         * The pattern of the string.\n         */\n        stringPattern?: RegExp | string;\n        /**\n         * Whether to ignore the casing of the enum values.\n         */\n        enumIgnoreCasing: boolean;\n        /**\n         * The minimum value of the number.\n         */\n        numberMinimum?: number;\n        /**\n         * The maximum value of the number.\n         */\n        numberMaximum?: number;\n        /**\n         * Whether the number must be an integer.\n         */\n        numberIsInteger: boolean;\n        /**\n         * The minimum value of the number (exclusive).\n         */\n        numberExclusiveMinimum?: number;\n        /**\n         * The maximum value of the number (exclusive).\n         */\n        numberExclusiveMaximum?: number;\n        /**\n         * The required properties of the JSON object.\n         */\n        jsonRequired: string[];\n        /**\n         * The minimum number of properties of the JSON object.\n         */\n        jsonMinProperties?: number;\n        /**\n         * The maximum number of properties of the JSON object.\n         */\n        jsonMaxProperties?: number;\n        /**\n         * Whether to allow additional properties of the JSON object.\n         */\n        jsonAdditionalProperties: boolean;\n        /**\n         * The separator of the array.\n         * @default ,\n         */\n        arraySeparator: string;\n        /**\n         * The minimum length of the array.\n         */\n        arrayMinLength?: number;\n        /**\n         * The maximum length of the array.\n         */\n        arrayMaxLength?: number;\n        /**\n         * Whether to ensure that the array has unique items.\n         * @default false\n         */\n        arrayUniqueItems: boolean;\n    }\n}\ndeclare module \"packages/env/src/lib/env-error\" {\n    /**\n     * Parsing error thrown when a value cannot be parsed from an environment variable.\n     */\n    export class EnvParsingError extends Error {\n        readonly variableName: string;\n        readonly value: unknown;\n        constructor(message: string, context: {\n            variableName: string;\n            value: unknown;\n        });\n    }\n    /**\n     * Validation error thrown when an environment variable value does not fulfill the validation criteria.\n     */\n    export class EnvValidationError extends Error {\n        readonly variableName: string;\n        readonly value: unknown;\n        constructor(message: string, context: {\n            variableName: string;\n            value: unknown;\n        });\n    }\n    /**\n     * Validation error thrown when an invalid input is provided to the method.\n     */\n    export class EnvInputValidationError extends Error {\n        readonly parameter: string;\n        readonly value: unknown;\n        constructor(message: string, context: {\n            parameter: string;\n            value: unknown;\n        });\n    }\n}\ndeclare module \"packages/env/src/lib/env-logger\" {\n    import { EnvConfiguration } from \"packages/env/src/lib/env-configuration.interface\";\n    export class EnvLogger {\n        private readonly config?;\n        constructor(config?: Partial<Pick<EnvConfiguration, 'debug' | 'logLevels'>>);\n        debug(message: string): void;\n        log(message: string): void;\n        warn(message: string): void;\n        error(message: string): void;\n    }\n}\ndeclare module \"packages/env/src/lib/env.utils\" {\n    import { EnvConfiguration } from \"packages/env/src/lib/env-configuration.interface\";\n    /**\n     * Parses an environment variable from the process environment.\n     * @param variableName The name of the environment variable to parse.\n     * @param config The parsing configuration to use.\n     * @returns The parsed environment variable value as a string, or undefined if the variable is not set.\n     */\n    export function parseEnvironmentVariable<RuntimeEnvironment extends {\n        [key: string]: string;\n    }>(variableName: string, config: Pick<EnvConfiguration<RuntimeEnvironment>, 'processEnv' | 'variableNamePrefix' | 'variableNameIgnoreCasing' | 'valueTrim' | 'valueEncoding' | 'valueRemoveAfterParse'>): string | undefined;\n    /**\n     * Parses a value to a boolean.\n     * @param value The value to parse.\n     * @param config The parsing configuration to use.\n     * @returns The parsed boolean value, or undefined if the value could not be parsed.\n     */\n    export function parseBooleanValue<RuntimeEnvironment extends {\n        [key: string]: string;\n    }>(value: unknown, config: Pick<EnvConfiguration<RuntimeEnvironment>, 'booleanTrueValues' | 'booleanFalseValues'>): boolean | undefined;\n    export function parseNumberValue(value: unknown): number | undefined;\n    export function validateNumberValue<RuntimeEnvironment extends {\n        [key: string]: string;\n    }>(value: number | undefined, config: Pick<EnvConfiguration<RuntimeEnvironment>, 'numberMinimum' | 'numberMaximum' | 'numberIsInteger' | 'numberExclusiveMinimum' | 'numberExclusiveMaximum'>): true | string;\n    export function validateStringValue<RuntimeEnvironment extends {\n        [key: string]: string;\n    }>(value: string | undefined, config: Pick<EnvConfiguration<RuntimeEnvironment>, 'stringMinLength' | 'stringMaxLength' | 'stringPattern'>): true | string;\n    export function parseEnumValue<TEnum extends {\n        [key: string]: string;\n    }, RuntimeEnvironment extends {\n        [key: string]: string;\n    }>(enumType: TEnum, value: unknown, config: Pick<EnvConfiguration<RuntimeEnvironment>, 'enumIgnoreCasing'>): TEnum[keyof TEnum] | undefined;\n    /**\n     * Parses a value to an array of strings.\n     * @param value The value to parse.\n     * @param config The parsing configuration to use.\n     * @returns The parsed array of strings, or undefined if the value could not be parsed.\n     */\n    export function parseArrayValue<RuntimeEnvironment extends {\n        [key: string]: string;\n    }>(value: unknown, config: Pick<EnvConfiguration<RuntimeEnvironment>, 'arraySeparator'>): string[] | undefined;\n    export function validateArrayValue<RuntimeEnvironment extends {\n        [key: string]: string;\n    }>(value: string[] | undefined, config: Pick<EnvConfiguration<RuntimeEnvironment>, 'arrayMinLength' | 'arrayMaxLength' | 'arrayUniqueItems'>): true | string;\n    export function isNotNullish<T>(el: T | null | undefined): el is T;\n    /**\n     * Assigns the properties of object2 to object1, but only if they are not undefined\n     * @param target Object to assign to\n     * @param source Object to assign from\n     * @returns The modified target object with the assigned properties\n     */\n    export function assignPartialObject<T extends object>(target: T, source: Partial<T> | undefined | null): T;\n}\ndeclare module \"packages/env/src/lib/env\" {\n    import { EnvConfiguration } from \"packages/env/src/lib/env-configuration.interface\";\n    import { EnvLogger } from \"packages/env/src/lib/env-logger\";\n    import { ArrayParsingOptions, BooleanParsingptions, EnumParsingOptions, JsonParsingOptions, NumberParsingOptions, StringParsingOptions } from \"packages/env/src/lib/env.interface\";\n    export class SkylineEnv<RuntimeEnvironment extends {\n        [key: string]: string;\n    }> {\n        private readonly config;\n        private readonly logger;\n        constructor(config?: Partial<EnvConfiguration<RuntimeEnvironment>> & {\n            logger?: EnvLogger;\n        });\n        /**\n         * Get the runtime environment.\n         * @returns The runtime environment or \"undefined\" if no runtime environment is set.\n         */\n        get runtime(): RuntimeEnvironment[keyof RuntimeEnvironment] | undefined;\n        /**\n         * Parse an environment variable as a boolean.\n         * @param variableName Name of the environment variable to parse\n         * @param options Optional parsing options\n         * @returns The parsed boolean value, or undefined if the variable is not set.\n         */\n        parseBoolean(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: boolean | (() => boolean);\n        }> & {\n            default: boolean | (() => boolean);\n        } & BooleanParsingptions): boolean;\n        parseBoolean(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: boolean | (() => boolean);\n        }> & {\n            default?: boolean | (() => boolean);\n        } & BooleanParsingptions): boolean | undefined;\n        /**\n         * Parse an environment variable as an array of booleans.\n         * @param variableName Name of the environment variable to parse\n         * @param options Optional parsing options\n         * @returns The parsed boolean array, or undefined if the variable is not set.\n         */\n        parseBooleanArray(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: boolean[] | (() => boolean[]);\n        }> & {\n            default: boolean[] | (() => boolean[]);\n        } & BooleanParsingptions & ArrayParsingOptions): boolean[];\n        parseBooleanArray(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: boolean[] | (() => boolean[]);\n        }> & {\n            default?: boolean[] | (() => boolean[]);\n        } & BooleanParsingptions & ArrayParsingOptions): boolean[] | undefined;\n        /**\n         * Parse an environment variable as a string.\n         * @param variableName Name of the environment variable to parse\n         * @param options Optional parsing options\n         * @returns The parsed string value, or undefined if the variable is not set.\n         */\n        parseString(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: string | (() => string);\n        }> & {\n            default: string | (() => string);\n        } & StringParsingOptions): string;\n        parseString(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: string | (() => string);\n        }> & {\n            default?: string | (() => string);\n        } & StringParsingOptions): string | undefined;\n        /**\n         * Parse an environment variable as an array of strings.\n         * @param variableName Name of the environment variable to parse\n         * @param options Optional parsing options\n         * @returns The parsed string array, or undefined if the variable is not set.\n         */\n        parseStringArray(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: string[] | (() => string[]);\n        }> & {\n            default: string[] | (() => string[]);\n        } & StringParsingOptions & ArrayParsingOptions): string[];\n        parseStringArray(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: string[] | (() => string[]);\n        }> & {\n            default?: string[] | (() => string[]);\n        } & StringParsingOptions & ArrayParsingOptions): string[] | undefined;\n        /**\n         * Parse an environment variable as an enum.\n         * @param variableName Name of the environment variable to parse\n         * @param enumType Enum type to parse the environment variable as\n         * @param options Optional parsing options\n         * @returns The parsed enum value, or undefined if the variable is not set.\n         */\n        parseEnum<TEnum extends {\n            [key: string]: string;\n        }>(variableName: string, enumType: TEnum, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: TEnum[keyof TEnum] | (() => TEnum[keyof TEnum]);\n        }> & EnumParsingOptions & {\n            default: TEnum[keyof TEnum] | (() => TEnum[keyof TEnum]);\n        }): TEnum[keyof TEnum];\n        parseEnum<TEnum extends {\n            [key: string]: string;\n        }>(variableName: string, enumType: TEnum, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: TEnum[keyof TEnum] | (() => TEnum[keyof TEnum]);\n        }> & EnumParsingOptions & {\n            default?: TEnum[keyof TEnum] | (() => TEnum[keyof TEnum]);\n        }): TEnum[keyof TEnum] | undefined;\n        /**\n         * Parse an environment variable as an enum.\n         * @param variableName Name of the environment variable to parse\n         * @param enumType Enum type to parse the environment variable as\n         * @param options Optional parsing options\n         */\n        parseEnumArray<TEnum extends {\n            [key: string]: string;\n        }>(variableName: string, enumType: TEnum, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: Array<TEnum[keyof TEnum]> | (() => Array<TEnum[keyof TEnum]>);\n        }> & EnumParsingOptions & ArrayParsingOptions & {\n            default: Array<TEnum[keyof TEnum]> | (() => Array<TEnum[keyof TEnum]>);\n        }): Array<TEnum[keyof TEnum]>;\n        parseEnumArray<TEnum extends {\n            [key: string]: string;\n        }>(variableName: string, enumType: TEnum, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: Array<TEnum[keyof TEnum]> | (() => Array<TEnum[keyof TEnum]>);\n        }> & EnumParsingOptions & ArrayParsingOptions & {\n            default?: Array<TEnum[keyof TEnum]> | (() => Array<TEnum[keyof TEnum]>);\n        }): Array<TEnum[keyof TEnum]> | undefined;\n        /**\n         * Parse an environment variable as a number.\n         * @param variableName Name of the environment variable to parse\n         * @param options Optional parsing options\n         * @returns The parsed number value, or undefined if the variable is not set.\n         */\n        parseNumber(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: number | (() => number);\n        }> & {\n            default: number | (() => number);\n        } & NumberParsingOptions): number;\n        parseNumber(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: number | (() => number);\n        }> & {\n            default?: number | (() => number);\n        } & NumberParsingOptions): number | undefined;\n        /**\n         * Parse an environment variable as an array of numbers.\n         * @param variableName Name of the environment variable to parse\n         * @param options Optional parsing options\n         * @returns The parsed number array, or undefined if the variable is not set.\n         */\n        parseNumberArray(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: number[] | (() => number[]);\n        }> & {\n            default: number[] | (() => number[]);\n        } & NumberParsingOptions & ArrayParsingOptions): number[];\n        parseNumberArray(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: number[] | (() => number[]);\n        }> & {\n            default?: number[] | (() => number[]);\n        } & NumberParsingOptions & ArrayParsingOptions): number[] | undefined;\n        /**\n         * Parse an environment variable as a JSON object.\n         * @param variableName Name of the environment variable to parse\n         * @param options Optional parsing options\n         */\n        parseJSON<TJson extends object>(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: TJson | (() => TJson);\n        }> & {\n            default: TJson | (() => TJson);\n        } & JsonParsingOptions): TJson;\n        parseJSON<TJson extends object>(variableName: string, options?: Partial<{\n            [key in keyof RuntimeEnvironment]: TJson | (() => TJson);\n        }> & {\n            default?: TJson | (() => TJson);\n        } & JsonParsingOptions): TJson | undefined;\n    }\n}\ndeclare module \"@skyline-js/env\" {\n    export * from \"packages/env/src/lib/env\";\n    export * from \"packages/env/src/lib/env-error\";\n    export * from \"packages/env/src/lib/env.interface\";\n    export * from \"packages/env/src/lib/env-configuration.interface\";\n}\n\n"}),this.addExtraTsLib({types:'\ndeclare module "packages/cache/src/lib/interface/cache-key.type" {\n    export type CacheKey = string | number | BigInt | boolean;\n}\ndeclare module "packages/cache/src/lib/cache-error" {\n    import type { CacheKey } from "packages/cache/src/lib/interface/cache-key.type";\n    export class CacheInconsistencyError extends Error {\n        readonly key: CacheKey;\n        readonly namespace: string;\n        readonly value: string;\n        readonly cachedValue: string;\n        constructor(message: string, context: {\n            key: CacheKey;\n            namespace: string;\n            value: string;\n            cachedValue: string;\n        });\n    }\n    export class CacheInputValidationError extends Error {\n        readonly parameter: string;\n        readonly value: unknown;\n        constructor(message: string, context: {\n            parameter: string;\n            value: unknown;\n        });\n    }\n    export class CacheStorageEngineError extends Error {\n        readonly operation: string;\n        readonly storageEninge: string;\n        constructor(message: string, context: {\n            operation: string;\n            storageEninge: string;\n        });\n    }\n}\ndeclare module "packages/cache/src/lib/logger/cache-logger.interface" {\n    import type { CacheKey } from "packages/cache/src/lib/interface/cache-key.type";\n    export interface CacheLoggerConfiguration {\n        enabled: boolean;\n        logLevels: CacheLogLevel[];\n    }\n    export enum CacheLogLevel {\n        LOG = "log",\n        WARN = "warn",\n        ERROR = "error"\n    }\n    export enum CacheMessageInfoType {\n        CACHE_STALE = "cache_stale",\n        UNKNOWN_ERROR = "unknown_error",\n        CACHE_INCONSISTENCY = "cache_inconsistency",\n        STORAGE_ENGINE_ERROR = "storage_engine_error",\n        INPUT_VALIDATION_ERROR = "input_validation_error"\n    }\n    interface CacheMessageInfo {\n        type: CacheMessageInfoType;\n    }\n    export interface CacheStaleMessageInfo extends CacheMessageInfo {\n        type: CacheMessageInfoType.CACHE_STALE;\n        key: CacheKey;\n        namespace: string;\n        durationMs: number;\n        staleThresholdMs: number;\n    }\n    export interface CacheUnknownErrorMessageInfo extends CacheMessageInfo {\n        type: CacheMessageInfoType.UNKNOWN_ERROR;\n        error: unknown;\n    }\n    export interface CacheInconsistencyMessageInfo extends CacheMessageInfo {\n        type: CacheMessageInfoType.CACHE_INCONSISTENCY;\n        key: CacheKey;\n        namespace: string;\n        value: string;\n        cachedValue: string;\n    }\n    export interface CacheInputValidationErrorMessageInfo extends CacheMessageInfo {\n        type: CacheMessageInfoType.INPUT_VALIDATION_ERROR;\n        parameter: string;\n        value: unknown;\n    }\n    export type CacheMessageInfoUnion = CacheStaleMessageInfo | CacheUnknownErrorMessageInfo | CacheInconsistencyMessageInfo | CacheInputValidationErrorMessageInfo;\n}\ndeclare module "packages/cache/src/lib/interface/cache-configuration.interface" {\n    import type { CacheLogLevel } from "packages/cache/src/lib/logger/cache-logger.interface";\n    export interface CacheConfiguration {\n        /**\n         * The prefix for all keys of this cache instance.         * Defaults to "cache"\n         */\n        cachePrefix: string;\n        /**\n         * Optional version for the cache. This can be used to invalidate the cache when the data structure has changed.         * Defaults to "undefined"\n         */\n        cacheVersion?: string;\n        /**\n         * Whether to force cache skips. This is useful for local development and CI environments to validate every cache.         * Defaults to "false"\n         */\n        forceCacheSkips: boolean;\n        /**\n         * Default expiration time in ms for cache entries.         * Defaults to 24 hours\n         */\n        defaultCacheExpirationMs: number;\n        /**\n         * Threshold in ms to consider data stale, causing the data to be discarded instead of writing it to the cache.         * Defaults to 2 seconds\n         */\n        staleThresholdMs: number;\n        /**\n         * Whether to disable namespaces on cache inconsistency.         * Defaults to "false"\n         */\n        disableNamespaces: boolean;\n        /**\n         * The prefix for the key to store disabled namespaces information in storage.         * Defaults to "disabled-namespaces"\n         */\n        disabledNamespacesKeyPrefix: string;\n        /**\n         * The interval in ms to check synchronize disabled namespaces from storage.         * Defaults to 30 seconds\n         */\n        disabledNamespacesSyncIntervalMs: number;\n        /**\n         * The expiration time in ms for disabling a namespace.         * Defaults to 24 hours\n         */\n        disabledNamespaceExpirationMs: number;\n        /**\n         * The value written to a key to block it.         * Defaults to "blocked"\n         */\n        cacheKeyBlockedValue: string;\n        /**\n         * The expiration time in ms for blocking a key.         * Defaults to 10 seconds\n         */\n        blockedKeyExpirationMs: number;\n        /**\n         * Whether to throw if an error occurrs.         * Defaults to "false"\n         */\n        throwOnError: boolean;\n        /**\n         * Whether logging is enabled.         * Defaults to "true"\n         */\n        loggingEnabled: boolean;\n        /**\n         * The log levels to log.         * Defaults to all available log levels\n         */\n        logLevels: CacheLogLevel[];\n        /**\n         * The seed for the random number generator\n         * Defaults to "cache-rnd-seed"\n         */\n        randomGeneratorSeed: string;\n    }\n}\ndeclare module "packages/cache/src/lib/interface/cache-statistics.interface" {\n    export interface CacheStatistics {\n        /** Number of cache hits */\n        numCacheHits: number;\n        /** Number of cache misses */\n        numCacheMisses: number;\n        /** Number of cache skips */\n        numCacheSkips: number;\n        /** Number of cache skips due to disabled namespaces */\n        numCacheDisabledNamespaceSkips: number;\n        /** Number of cache invalidations */\n        numCacheInvalidations: number;\n        /** Number of cache consistency checks */\n        numCacheConsistencyChecks: number;\n        /** Number of cache inconsistencies */\n        numCacheInconsistencies: number;\n        /** Number of unknown cache errors */\n        numCacheErrors: number;\n    }\n}\ndeclare module "packages/cache/src/lib/cache.utils" {\n    export function isNotNullish<T>(el: T | null | undefined): el is T;\n    export function isNullish<T>(value?: T | null | undefined): value is null | undefined;\n    export function extractMessageFromError(error: unknown): string | undefined;\n    export function extractStackFromError(error: unknown): string | undefined;\n    /**\n     * Get a random number generator based on a seed string\n     * @param seed The seed string\n     * @returns A random number generator that produces a number between 0 and 1\n     */\n    export function getRandomNumberGenerator(seed?: string): () => number;\n}\ndeclare module "packages/cache/src/lib/logger/cache-logger" {\n    import { CacheLoggerConfiguration, CacheMessageInfoUnion } from "packages/cache/src/lib/logger/cache-logger.interface";\n    export class CacheLogger {\n        private readonly config?;\n        constructor(config?: Partial<CacheLoggerConfiguration>);\n        log(message: string, info: CacheMessageInfoUnion): void;\n        warn(message: string, info: CacheMessageInfoUnion): void;\n        error(message: string, info: CacheMessageInfoUnion): void;\n    }\n}\ndeclare module "packages/cache/src/lib/storage-engine/cache-storage-engine" {\n    /**\n     * The interface for a cache storage engine.\n     */\n    export abstract class CacheStorageEngine {\n        /**\n         * Get a value from the cache\n         * @param key The key to get the value for\n         * @returns The value or "undefined" if not found\n         */\n        abstract get(key: string): Promise<string | undefined>;\n        abstract getMany(keys: string[]): Promise<Array<string | undefined>>;\n        abstract getKeysByPattern(pattern: string): Promise<string[]>;\n        /**\n         * Set a value for a key.\n         * @param key The key to set the value for.\n         * @param value The value to set.\n         * @param opts.expiresIn The time in milliseconds after which the value should expire.\n         */\n        abstract set(key: string, value: string, opts?: {\n            expiresIn?: number;\n        }): Promise<unknown>;\n        abstract setMany(inputs: {\n            key: string;\n            value: string;\n            expiresIn?: number;\n        }[]): Promise<unknown>;\n        /**\n         * Set a value for a key if it does not exist yet.\n         * @param key The key to set the value for.\n         * @param value The value to set.\n         * @param opts.expiresIn The time in milliseconds after which the value should expire.\n         */\n        abstract setIfNotExist(key: string, value: string, opts?: {\n            expiresIn?: number;\n        }): Promise<unknown>;\n        abstract setManyIfNotExist(inputs: {\n            key: string;\n            value: string;\n            expiresIn?: number;\n        }[]): Promise<unknown>;\n    }\n}\ndeclare module "packages/cache/src/lib/storage-engine/in-memory-cache-storage-engine" {\n    import { CacheStorageEngine } from "packages/cache/src/lib/storage-engine/cache-storage-engine";\n    interface InMemoryCacheStorageEngineConfiguration {\n        periodicCleanup?: boolean;\n        cleanupIntervalMs: number;\n    }\n    /**\n     * A cache storage engine that stores the cache in memory.\n     */\n    export class InMemoryCacheStorageEngine extends CacheStorageEngine {\n        private readonly config;\n        private readonly cache;\n        constructor(config?: Partial<InMemoryCacheStorageEngineConfiguration>);\n        /**\n         * Get a value from the cache\n         * @param key The key to get the value for\n         * @returns The value or "undefined" if not found\n         */\n        get(key: string): Promise<string | undefined>;\n        getMany(keys: string[]): Promise<Array<string | undefined>>;\n        ttl(key: string): Promise<number | undefined>;\n        /**\n         * Get all keys matching a pattern. The pattern can contain "*" as a wildcard, which matches any number of characters (including zero)\n         * @param pattern The pattern to match\n         * @returns The keys matching the pattern\n         */\n        getKeysByPattern(_pattern: string): Promise<string[]>;\n        /**\n         * Set a value for a key.\n         * @param key The key to set the value for.\n         * @param value The value to set.\n         * @param opts.expiresIn The time in milliseconds after which the value should expire.\n         */\n        set(key: string, value: string, opts?: {\n            expiresIn?: number;\n        }): Promise<void>;\n        setMany(inputs: {\n            key: string;\n            value: string;\n            expiresIn?: number;\n        }[]): Promise<void>;\n        setIfNotExist(key: string, value: string, opts?: {\n            expiresIn?: number;\n        }): Promise<void>;\n        setManyIfNotExist(inputs: {\n            key: string;\n            value: string;\n            expiresIn?: number;\n        }[]): Promise<void>;\n    }\n}\ndeclare module "packages/cache/src/lib/cache" {\n    import { CacheConfiguration } from "packages/cache/src/lib/interface/cache-configuration.interface";\n    import { CacheStatistics } from "packages/cache/src/lib/interface/cache-statistics.interface";\n    import { CacheKey } from "packages/cache/src/lib/interface/cache-key.type";\n    import { CacheLogger } from "packages/cache/src/lib/logger/cache-logger";\n    import { CacheStorageEngine } from "packages/cache/src/lib/storage-engine/cache-storage-engine";\n    /**\n     * ### SkylineCache\n     *\n     * TODO: Good documentation\n     * Results of source queries can be cached by their primary key. A typical caching operation consists of the "namespace" (e.g. "user") and the primary key (e.g. the user ID: "123").\n     * Aggregate results can also be cached. For example, all user IDs for the organization. In this case, the namespace would be "organization-user-ids" and the primary key would be "organizationId".\n     * To avoid timing bugs, the cache invalidation blocks the key for a short period of time. Writing to a cache key is only possible if the key does not exist.\n     * The cache key invalidation should happen at the end of the source transaction but before the transaction is committed.\n     * A transaction gets the source from one consistent state to another consistent state. If we would invalidate the caches after the transaction is committed, we might return an inconsistent state because some caches might be invalidated and some might not.\n     * If a transaction is long-running, invalidating the cache key at the start of the transaction might be insufficient as the blocking period might run out before the transaction is committed.\n     * Therefore, we "collect" the cache keys that need to be invalidated during the transaction and invalidate them right before the transaction is committed.\n     *\n     * # Cache consistency observability\n     * It is close to impossible to write bug-free cache invalidation code. Therefore, we need to be able to observe the cache consistency and react to inconsistencies.\n     * The cache consistency observability is implemented by using the following strategy:\n     * The developer can configure a percentage of cache reads that should be skipped. This value should be 100% when a cache is first introduced. This way no cached values are used and every cached value will be checked for correctness.\n     * As the "get" / "getMany" function returns an artifical cache miss, the application goes on and fetches the data from the source. Afterwards, the fetched values will be written to cache via the "setIfNotExist" / "setManyIfNotExist" functions.\n     * These functions check if the key already exists. If so, the given value will be compared with the cached value. If the values are not equal, an cache inconsistency is detected and an exception will be thrown.\n     * When no cache inconsistencies are observed, the percentage value can be gradually lowered so that we enjoy the benefits of the caching with increasing confidence in the consistency of the cache. The value should never be 0%, otherwise\n     * we have no way of observing cache inconsistencies.\n     *\n     * Potential causes for cache inconsistencies:\n     *   - Developer forgets to invalidate the cache (deterministic inconsistency)\n     *   - Transaction committing takes longer than the cache key blocking period (timing dependent inconsistency)\n     *   - The staleness check passes but the writing to cache takes longer than blocking period (timing dependent inconsistency)\n     */\n    export class SkylineCache {\n        private readonly config;\n        private readonly storage;\n        private readonly logger;\n        private readonly random;\n        /** Whether the cache skipping feature is disabled */\n        private cacheSkippingDisabled;\n        /** Disabled namespaces (e.g., due to detected cache inconsistency) */\n        private disabledNamespaces;\n        /** Cache statistics */\n        private readonly statistics;\n        constructor({ config, storage, logger, }?: {\n            config?: Partial<CacheConfiguration>;\n            storage?: CacheStorageEngine;\n            logger?: CacheLogger | typeof CacheLogger;\n        });\n        /**\n         * Get the storage key for a given namespace and key.\n         * Takes the cache prefix and cache version into account if configured.\n         * @param namespace The namespace.\n         * @param key The key.\n         * @returns The storage key.\n         */\n        private getStorageKey;\n        /**\n         * Get a value from the cache.\n         * @param namespace The namespace of the cached value (e.g. "user").\n         * @param key The key of the cached value (e.g. the user ID: "123")\n         * @param validator A validator function to validate the cached value.\n         * @param opts.skip A probability between 0 and 1 whether the cache read should be skipped.\n         *                  This is used to detect cache inconsistencies.\n         *                  If the cache read is skipped, the function artifically returns "undefined" (= cache miss).\n         *                  Defaults to 0 (0% of cache reads are skipped).\n         * @returns The cached value if it exists and is valid, "undefined" otherwise.\n         */\n        get<T>(namespace: string, key: CacheKey, validator: (input: unknown) => asserts input is T, opts?: {\n            skip?: number;\n        }): Promise<{\n            value: T | undefined;\n            skipped: boolean;\n        }>;\n        /**\n         * Get multiple values from the cache.\n         * @param namespace The namespace of the cached values (e.g. "user").\n         * @param keys The keys of the cached values (e.g. the user IDs: ["123", "456"])\n         * @param validator A validator function to validate each cached value.\n         * @param opts.skip A probability between 0 and 1 whether the cache read should be skipped.\n         *                  This is used to detect cache inconsistencies.\n         *                  If the cache read is skipped, the function artifically returns "undefined" (= cache miss).\n         *                  Defaults to 0 (0% of cache reads are skipped).\n         * @returns An array containing the cached values if they exist and are valid, "undefined" otherwise.\n         *          The order of the array is the same as the order of the input keys.\n         *          The length of the array is the same as the length of the input keys.\n         */\n        getMany<T>(namespace: string, keys: ReadonlyArray<CacheKey>, validator: (input: unknown) => asserts input is T, opts?: {\n            skip?: number;\n        }): Promise<{\n            values: Array<T | undefined>;\n            skipped: boolean;\n        }>;\n        /**\n         * Set a cache value in the cache if it does not already exist.\n         * This operation does nothing if the value already exists or is blocked.\n         * @param namespace The namespace of the cached value (e.g. "user").\n         * @param keyFunc A function to calculate the key of the cached value (e.g. the user ID: "123").\n         * @param value  The value to cache.\n         * @param opts.fetchedAt The timestamp when the value was fetched from the source.\n         *                       Used to determine if the value is stale (time difference is above the stale threshold).\n         *                       Timestamp is in UNIX milliseconds.\n         * @param opts.expiresIn The expiration of the cached value in milliseconds.\n         * @param opts.validate  Whether the cache value should be validated.\n         *                       This is used to detect cache inconsistencies.\n         *                       Defaults to false (no cache values are validated).\n         */\n        setIfNotExist<T>(namespace: string, keyFunc: (input: T) => CacheKey, value: T, { fetchedAt, expiresIn, ...opts }: {\n            fetchedAt: number;\n            expiresIn?: number;\n            validate?: boolean;\n        }): Promise<void>;\n        /**\n         * Set multiple cache values in the cache if they do not already exist.\n         * @param namespace The namespace of the cached values (e.g. "user").\n         * @param keyFunc A function to calculate the key of the cached value (e.g. the user ID: "123").\n         * @param values The values to cache.\n         * @param opts.fetchedAt The timestamp when the value was fetched from the source. Used to determine if the value is stale (time difference is above the stale threshold). Timestamp is in UNIX milliseconds.\n         * @param opts.expiresIn The expiration of the cached value in milliseconds.\n         * @param opts.validate  Whether the cache value should be validated.\n         *                       This is used to detect cache inconsistencies.\n         *                       Defaults to false (no cache values are validated).\n         */\n        setManyIfNotExist<T>(namespace: string, keyFunc: (input: T) => CacheKey, values: T[], { fetchedAt, expiresIn, ...opts }: {\n            fetchedAt: number;\n            expiresIn?: number;\n            validate?: boolean;\n        }): Promise<void>;\n        /**\n         * Invalidate a cache value in the cache. Blocks the key for a short period of time to avoid timing bugs.\n         * @param namespace The namespace of the cached value (e.g. "user").\n         * @param key The key of the cached value (e.g. the user ID: "123").\n         * @param opts.expiresIn The expiration of the blocked state in milliseconds.\n         */\n        invalidate(namespace: string, key: CacheKey, { expiresIn }?: {\n            expiresIn?: number;\n        }): Promise<void>;\n        /**\n         * Invalidate multiple cache values in the cache. Blocks each key for a short period of time to avoid timing bugs.\n         * @param keys Array of namespace and key pairs to invalidate.\n         * @param opts.expiresIn The expiration of the blocked state in milliseconds.\n         */\n        invalidateMany(keys: ReadonlyArray<{\n            namespace: string;\n            key: CacheKey;\n        }>, { expiresIn }?: {\n            expiresIn?: number;\n        }): Promise<void>;\n        /**\n         * Private/ internal function to check the cache consistency.\n         * @param valueStr The value to check.\n         * @param cachedValueStr The cached value to check.\n         * @param context The context in which the check is performed.\n         */\n        private checkCacheConsistency;\n        /**\n         * Private/ internal function to handle errors that occurred while handling the cache.\n         * Handle an error that occurred while handling the cache.\n         * @param error The error that occurred.\n         * @param context The context in which the error occurred.\n         */\n        private handleError;\n        /**\n         * Dump the entire contents of the cache.\n         * This should only be used for debugging purposes.\n         */\n        dumpCache(): Promise<{\n            [key: string]: string | undefined;\n        }>;\n        /**\n         * Get caching statistics.\n         * @returns The caching statistics.\n         */\n        getStatistics(): CacheStatistics;\n        /**\n         * Reset caching statistics.\n         */\n        resetStatistics(): void;\n        /**\n         * Enables the cache skipping feature. This restore the default behavior of cache skips.          * This function only needs to be called if cache skips have been disabled in the first place.\n         */\n        enableCacheSkipping(): void;\n        /**\n         * Disable the cache skipping feature.          * This is useful for local development to see how the application behaves with full cache hits.          * This is equivalent to setting skip: 0 for all cache read operations.          * This option takes precedence over forceCacheSkips.\n         */\n        disableCacheSkipping(): void;\n        /**\n         * Private/ internal function to check if a namespace is disabled.\n         * @param namespace The namespace to check.\n         * @returns True if the namespace is disabled, false otherwise.\n         */\n        private isNamespaceDisabled;\n        /**\n         * Private/ internal function to disable a namespace.\n         * @param namespace The namespace to disable.\n         */\n        private disableNamespace;\n        /**\n         * Synchronize the disabled namespaces.\n         * This function is periodically called to synchronize the disabled namespaces from storage.\n         */\n        synchronizeDisabledNamespaces(): Promise<void>;\n        /**\n         * Get the disabled namespaces.\n         * The namespaces are periodically synchronized from storage.\n         * Therefore, only the namespaces that have been synchronized are returned.\n         * @returns The disabled namespaces.\n         */\n        getDisabledNamespaces(): string[];\n        /**\n         * Set disabled namespaces.\n         * Use this method if you want to manually handle namespace disabling.\n         * @param namespaces The namespaces to disable.\n         */\n        setDisabledNamespaces(...namespaces: string[]): void;\n        /**\n         * Remove all disabled namespaces.\n         * Use this method if you want to manually handle namespace disabling.\n         */\n        clearDisabledNamespaces(): void;\n    }\n}\ndeclare module "packages/cache/src/lib/storage-engine/redis-cache-storage-engine.interface" {\n    /**\n     * ioredis client interface\n     */\n    export interface IoRedisClient {\n        multi(options: {\n            pipeline: false;\n        }): Promise<\'OK\'>;\n        multi(): IoRedisChainableCommander;\n        multi(options: {\n            pipeline: true;\n        }): IoRedisChainableCommander;\n        multi(commands?: unknown[][]): IoRedisChainableCommander;\n        get(key: string): Promise<string | null | undefined>;\n        mget(keys: string[]): Promise<Array<string | null | undefined>>;\n        keys(pattern: string): Promise<string[]>;\n    }\n    type Callback<T = any> = (err?: Error | null, result?: T) => void;\n    interface IoRedisChainableCommander {\n        exec(callback?: Callback<[error: Error | null, result: unknown][] | null>): Promise<[error: Error | null, result: unknown][] | null>;\n        set(key: string, value: string): IoRedisChainableCommander;\n        set(key: string, value: string, secondsToken: \'EX\', seconds: number | string): IoRedisChainableCommander;\n        set(key: string, value: string, nx: \'NX\'): IoRedisChainableCommander;\n        set(key: string, value: string, secondsToken: \'EX\', seconds: number | string, nx: \'NX\'): IoRedisChainableCommander;\n    }\n    /**\n     * node-redis client interface\n     */\n    export interface NodeRedisClient {\n        multi: () => NodeRedisClientMultiCommand;\n        get(key: string): Promise<string | null | undefined>;\n        mGet(keys: string[]): Promise<Array<string | null | undefined>>;\n        keys(pattern: string): Promise<string[]>;\n    }\n    type MaximumOneOf<T, K extends keyof T = keyof T> = K extends keyof T ? {\n        [P in K]?: T[K];\n    } & Partial<Record<Exclude<keyof T, K>, never>> : never;\n    type SetTTL = MaximumOneOf<{\n        EX: number;\n        PX: number;\n        EXAT: number;\n        PXAT: number;\n        KEEPTTL: true;\n    }>;\n    type SetGuards = MaximumOneOf<{\n        NX: true;\n        XX: true;\n    }>;\n    interface SetCommonOptions {\n        GET?: true;\n    }\n    type NodeRedisSetOptions = SetTTL & SetGuards & SetCommonOptions;\n    interface NodeRedisClientMultiCommand {\n        exec(): Promise<Array<any>>;\n        set(key: string, value: string, options: NodeRedisSetOptions): NodeRedisClientMultiCommand;\n    }\n    /**\n     * Unified redis client interface\n     */\n    export interface RedisClient {\n        multi(): RedisClientChainable;\n        get(key: string): Promise<string | null | undefined>;\n        mget(keys: string[]): Promise<Array<string | null | undefined>>;\n        keys(pattern: string): Promise<string[]>;\n    }\n    interface RedisClientChainable {\n        exec(): Promise<unknown>;\n        set(key: string, value: string, options: {\n            ex?: number;\n            nx?: boolean;\n        }): RedisClientChainable;\n    }\n}\ndeclare module "packages/cache/src/lib/storage-engine/redis-cache-storage-engine.utils" {\n    import { IoRedisClient, NodeRedisClient, RedisClient } from "packages/cache/src/lib/storage-engine/redis-cache-storage-engine.interface";\n    export function getRedisClientFromNodeOrIoRedisClient(client: IoRedisClient | NodeRedisClient): RedisClient;\n    export function getRedisClientFromNodeRedisClient(client: NodeRedisClient): RedisClient;\n    export function getRedisClientFromIoRedisClient(client: IoRedisClient): RedisClient;\n}\ndeclare module "packages/cache/src/lib/storage-engine/redis-cache-storage-engine" {\n    import { CacheStorageEngine } from "packages/cache/src/lib/storage-engine/cache-storage-engine";\n    import { IoRedisClient, NodeRedisClient } from "packages/cache/src/lib/storage-engine/redis-cache-storage-engine.interface";\n    /**\n     * A cache storage engine that stores the cache in Redis.\n     */\n    export class RedisCacheStorageEngine extends CacheStorageEngine {\n        private readonly redis;\n        constructor({ redis }: {\n            redis: IoRedisClient | NodeRedisClient;\n        });\n        get(key: string): Promise<string | undefined>;\n        getMany(keys: string[]): Promise<Array<string | undefined>>;\n        getKeysByPattern(pattern: string): Promise<string[]>;\n        setMany(inputs: {\n            key: string;\n            value: string;\n            expiresIn: number;\n        }[]): Promise<unknown>;\n        set(key: string, value: string, opts: {\n            expiresIn: number;\n        }): Promise<unknown>;\n        setIfNotExist(key: string, value: string, opts: {\n            expiresIn: number;\n        }): Promise<unknown>;\n        setManyIfNotExist(inputs: {\n            key: string;\n            value: string;\n            expiresIn: number;\n        }[]): Promise<unknown>;\n    }\n}\ndeclare module "@skyline-js/cache" {\n    export * from "packages/cache/src/lib/cache";\n    export * from "packages/cache/src/lib/cache-error";\n    export * from "packages/cache/src/lib/interface/cache-key.type";\n    export * from "packages/cache/src/lib/interface/cache-statistics.interface";\n    export * from "packages/cache/src/lib/interface/cache-configuration.interface";\n    export * from "packages/cache/src/lib/logger/cache-logger";\n    export * from "packages/cache/src/lib/logger/cache-logger.interface";\n    export * from "packages/cache/src/lib/storage-engine/cache-storage-engine";\n    export * from "packages/cache/src/lib/storage-engine/redis-cache-storage-engine";\n    export * from "packages/cache/src/lib/storage-engine/in-memory-cache-storage-engine";\n}\n\n'}),this.addExtraTsLib({types:'\ndeclare module "packages/translate/src/lib/translate.interface" {\n    const isTranslationKey: unique symbol;\n    export type TranslationKey = string & {\n        [isTranslationKey]: true;\n    };\n    export type TranslationParameter = string | number | BigInt | undefined;\n    export enum TranslateLogLevel {\n        DEBUG = "DEBUG",\n        LOG = "LOG",\n        WARN = "WARN",\n        ERROR = "ERROR"\n    }\n    export interface TranslationParameters {\n        [key: string]: TranslationParameters | TranslationParameter;\n    }\n    export interface RecursiveStringObject {\n        [key: string]: RecursiveStringObject | string;\n    }\n    export type CastToTranslationKeys<O> = {\n        [P in keyof O]: O[P] extends string ? TranslationKey : CastToTranslationKeys<O[P]>;\n    };\n}\ndeclare module "packages/translate/src/lib/translate-configuration.interface" {\n    import { TranslateLogLevel, TranslationParameters } from "packages/translate/src/lib/translate.interface";\n    export interface TranslateConfiguration {\n        /** The language to translate to. If multiple languages are provided, the first available translation is used */\n        language?: string;\n        /** The language to fallback to if no translations for the selected language are available */\n        fallbackLanguage?: string;\n        /** Whitelist available languages. If a translations object contains a language that is not in this list, an error is thrown */\n        availableLanguages?: {\n            [key: string]: string;\n        } | string[];\n        /** Whether to use fuzzy matching for the language: ignore case, whitespaces, "*" wildcard support, fallback to same language with no culture or another culture */\n        languageFuzzyMatching?: boolean;\n        /** The interpolation pattern, can be a RegExp or an object with prefix and suffix (e.g. { prefix: \'{{\', suffix: \'}}\' }) */\n        interpolation: RegExp | {\n            prefix: string;\n            suffix: string;\n        };\n        /** The parameters to use for interpolation. */\n        params?: TranslationParameters;\n        /** The separator to specify the path to a parameter (e.g. \'user.name\' for { user: { name: \'John\' } }) */\n        paramKeySeparator: string;\n        /**\n         * How to handle missing parameters: \'keep\' (keep the handlebars), \'remove\' (remove the handlebars), \'throw\' (throw an error)\n         * @default \'keep\'\n         */\n        handleMissingParam: \'keep\' | \'remove\' | \'throw\';\n        /**\n         * How to handle missing translations: \'keep\' (keep the translation key), \'remove\' (remove the translation key), \'throw\' (throw an error)\n         */\n        handleMissingTranslation: \'keep\' | \'remove\' | \'throw\';\n        /**\n         * Whether logging is enabled.         * Defaults to "true"\n         */\n        loggingEnabled: boolean;\n        /**\n         * The log levels to log.         * Defaults to all available log levels\n         */\n        logLevels: TranslateLogLevel[];\n    }\n}\ndeclare module "packages/translate/src/lib/util/helper.utils" {\n    /**\n     * Assigns the properties of object2 to object1, but only if they are not undefined\n     * @param target Object to assign to\n     * @param source Object to assign from\n     * @returns The modified target object with the assigned properties\n     */\n    export function assignPartialObject<T extends object>(target: T, source: Partial<T> | undefined | null): T;\n}\ndeclare module "packages/translate/src/lib/util/interpolation.utils" {\n    import { TranslateConfiguration } from "packages/translate/src/lib/translate-configuration.interface";\n    export function substituteInterpolations({ template, config, }: {\n        template: string | undefined;\n        config: TranslateConfiguration;\n    }): string | undefined;\n}\ndeclare module "packages/translate/src/lib/util/translate.utils" {\n    import { TranslateConfiguration } from "packages/translate/src/lib/translate-configuration.interface";\n    import { CastToTranslationKeys, RecursiveStringObject, TranslationKey } from "packages/translate/src/lib/translate.interface";\n    /**\n     * Create a translation keys object with the same structure as the translation object, but with the values replaced by the translation keys\n     * @param translation The translation object\n     * @param parentPaths The parent paths (used for recursion)\n     * @returns The translation keys object\n     */\n    export function getTranslationKeysObject<Translations extends Record<string, RecursiveStringObject>>(translation: RecursiveStringObject, parentPaths?: string[]): CastToTranslationKeys<Translations[keyof Translations]>;\n    export function getTranslationTemplate({ key, config, translations, }: {\n        translations: any;\n        config: TranslateConfiguration;\n        key: TranslationKey | undefined | null;\n    }): string | undefined;\n}\ndeclare module "packages/translate/src/lib/translate" {\n    import { TranslateConfiguration } from "packages/translate/src/lib/translate-configuration.interface";\n    import { CastToTranslationKeys, RecursiveStringObject, TranslationKey } from "packages/translate/src/lib/translate.interface";\n    /**\n     * The SkylineTranslate class\n     */\n    export class SkylineTranslate<Translations extends Record<string, RecursiveStringObject>> {\n        private readonly translations;\n        private readonly config;\n        private keys;\n        constructor(translations: Translations, config?: Partial<TranslateConfiguration>);\n        /**\n         * Get the translation keys object\n         */\n        get key(): CastToTranslationKeys<Translations[keyof Translations]>;\n        /**\n         * Translate a string using the provided translation key and options\n         * @param key The translation key\n         * @param options The translation options\n         * @returns The translated string\n         */\n        translate(key: TranslationKey | undefined | null, options?: Partial<TranslateConfiguration>): string;\n    }\n    /**\n     * Create a SkylineTranslate class with default configuration\n     * @param defaultConfig The default configuration\n     * @returns The SkylineTranslate class with default configuration\n     */\n    export function configureSkylineTranslate(defaultConfig: Partial<TranslateConfiguration>): typeof SkylineTranslate;\n}\ndeclare module "packages/translate/src/lib/translate-logger" {\n    import { TranslateConfiguration } from "packages/translate/src/lib/translate-configuration.interface";\n    export class TranslateLogger {\n        private readonly config?;\n        constructor(config?: Partial<Pick<TranslateConfiguration, \'loggingEnabled\' | \'logLevels\'>>);\n        debug(message: string): void;\n        log(message: string): void;\n        warn(message: string): void;\n        error(message: string): void;\n    }\n}\ndeclare module "packages/translate/src/lib/util/http-request.utils" {\n    /**\n     * Parse HTTP header "Accept-Language" to get the languages accepted by the client.\n     * @param headers The HTTP request\'s headers object or the "Accept-Language" header value\n     * @returns The languages accepted by the client, sorted by q value (highest q value first)\n     */\n    export function parseHttpHeaderAcceptLanguages(headers?: {\n        [key: string]: string | string[];\n    } | string | string[] | null | undefined): string[];\n}\ndeclare module "packages/translate/src/lib/util/browser.utils" {\n    export function getBrowserLanguage(): string | undefined;\n    export function getBrowserCultureLanguage(): string | undefined;\n}\ndeclare module "@skyline-js/translate" {\n    export * from "packages/translate/src/lib/translate";\n    export * from "packages/translate/src/lib/translate-configuration.interface";\n    export * from "packages/translate/src/lib/translate-logger";\n    export { TranslationKey, TranslationParameter, TranslationParameters, } from "packages/translate/src/lib/translate.interface";\n    export { parseHttpHeaderAcceptLanguages } from "packages/translate/src/lib/util/http-request.utils";\n    export { getBrowserLanguage, getBrowserCultureLanguage } from "packages/translate/src/lib/util/browser.utils";\n}\n\n'}))}setMonacoTypescriptDefaults(){this.monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({noSemanticValidation:!1,noSyntaxValidation:!1,diagnosticCodesToIgnore:[1375,2339,2345,2451,2584,2585,2531,6200,1108,2582]}),this.monaco.languages.typescript.typescriptDefaults.setCompilerOptions({target:this.monaco.languages.typescript.ScriptTarget.ES2020,module:this.monaco.languages.typescript.ModuleKind.ESNext,allowNonTsExtensions:!0,noLib:!1}),this.monaco.languages.typescript.typescriptDefaults.setEagerModelSync(!0),this.monaco.languages.typescript.typescriptDefaults.setExtraLibs([])}addExtraTsLib(e){let{filename:n,types:a}=e;if(!this.monaco)throw new Error("MonacoService.addExtraTsLib was called before initialization!");return this.monaco.languages.typescript.typescriptDefaults.addExtraLib(a,n)}};class r extends s.Component{render(){return s.createElement("div",{style:{width:"100%",height:this.props.height??"300px",overflow:"hidden",background:"rgb(30, 30, 30)",borderRadius:"var(--ifm-code-border-radius)"}},s.createElement(t.ZP,{height:"100%",width:"100%",language:"typescript",defaultLanguage:"typescript",theme:"vs-dark",options:{language:"typescript",theme:"vs-dark",contextmenu:!0,fixedOverflowWidgets:!0,lineDecorationsWidth:12,padding:{top:16,bottom:16},scrollbar:{vertical:"auto",handleMouseWheel:!0,alwaysConsumeMouseWheel:!1},minimap:{enabled:!1},folding:!0},defaultValue:this.getStringChildren(),onMount:(e,n)=>{i.initMonaco(n)}}))}getStringChildren(){let e=this.props.children;for(;"string"!=typeof e&&e?.props?.children;)e=e.props.children;return"string"==typeof e?e:""}}},8480:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>g,contentTitle:()=>u,default:()=>y,frontMatter:()=>p,metadata:()=>d,toc:()=>f});var t=a(7462),s=a(7294),i=a(3905),r=a(8192),o=a(6857);const c=JSON.parse('[{"timestamp":"18:10","Cache hits":12735,"Cache misses":1325,"Cache skips":3669,"Consistency checks":3156,"Cache invalidations":4},{"timestamp":"18:20","Cache hits":24654,"Cache misses":10099,"Cache skips":9021,"Consistency checks":7778,"Cache invalidations":7},{"timestamp":"18:30","Cache hits":13991,"Cache misses":2742,"Cache skips":5903,"Consistency checks":4899,"Cache invalidations":1214},{"timestamp":"18:40","Cache hits":20574,"Cache misses":5216,"Cache skips":8459,"Consistency checks":7055,"Cache invalidations":1114},{"timestamp":"18:50","Cache hits":27063,"Cache misses":5570,"Cache skips":9636,"Consistency checks":8276,"Cache invalidations":1167},{"timestamp":"19:00","Cache hits":21066,"Cache misses":10346,"Cache skips":8513,"Consistency checks":7370,"Cache invalidations":2216},{"timestamp":"19:10","Cache hits":14293,"Cache misses":8412,"Cache skips":6095,"Consistency checks":5314,"Cache invalidations":1152},{"timestamp":"19:20","Cache hits":16176,"Cache misses":3664,"Cache skips":6360,"Consistency checks":5500,"Cache invalidations":2300},{"timestamp":"19:30","Cache hits":15701,"Cache misses":5317,"Cache skips":7049,"Consistency checks":6120,"Cache invalidations":1969},{"timestamp":"19:40","Cache hits":17575,"Cache misses":10759,"Cache skips":8157,"Consistency checks":6905,"Cache invalidations":2151},{"timestamp":"19:50","Cache hits":18057,"Cache misses":5361,"Cache skips":6081,"Consistency checks":5168,"Cache invalidations":2},{"timestamp":"20:00","Cache hits":23974,"Cache misses":5384,"Cache skips":8403,"Consistency checks":7247,"Cache invalidations":1581},{"timestamp":"20:10","Cache hits":27115,"Cache misses":6664,"Cache skips":9390,"Consistency checks":8180,"Cache invalidations":2117},{"timestamp":"20:20","Cache hits":22088,"Cache misses":3278,"Cache skips":7761,"Consistency checks":6662,"Cache invalidations":1977},{"timestamp":"20:30","Cache hits":24424,"Cache misses":4557,"Cache skips":8501,"Consistency checks":7376,"Cache invalidations":1155},{"timestamp":"20:40","Cache hits":18064,"Cache misses":3318,"Cache skips":6447,"Consistency checks":5751,"Cache invalidations":6},{"timestamp":"20:50","Cache hits":20348,"Cache misses":4524,"Cache skips":7556,"Consistency checks":6498,"Cache invalidations":5},{"timestamp":"21:00","Cache hits":10443,"Cache misses":2076,"Cache skips":5132,"Consistency checks":4536,"Cache invalidations":5},{"timestamp":"21:10","Cache hits":18864,"Cache misses":4535,"Cache skips":6963,"Consistency checks":5647,"Cache invalidations":3279},{"timestamp":"21:20","Cache hits":32744,"Cache misses":13644,"Cache skips":12853,"Consistency checks":11538,"Cache invalidations":2555},{"timestamp":"21:30","Cache hits":45783,"Cache misses":23412,"Cache skips":19638,"Consistency checks":17225,"Cache invalidations":2960},{"timestamp":"21:40","Cache hits":19526,"Cache misses":5179,"Cache skips":6698,"Consistency checks":6021,"Cache invalidations":1231},{"timestamp":"21:50","Cache hits":29559,"Cache misses":6058,"Cache skips":9466,"Consistency checks":8306,"Cache invalidations":1790},{"timestamp":"22:00","Cache hits":19097,"Cache misses":3918,"Cache skips":6190,"Consistency checks":5191,"Cache invalidations":1148},{"timestamp":"22:10","Cache hits":22835,"Cache misses":7645,"Cache skips":8216,"Consistency checks":7202,"Cache invalidations":1245},{"timestamp":"22:20","Cache hits":12320,"Cache misses":2898,"Cache skips":4833,"Consistency checks":4236,"Cache invalidations":8},{"timestamp":"22:30","Cache hits":19818,"Cache misses":3782,"Cache skips":6594,"Consistency checks":5729,"Cache invalidations":1},{"timestamp":"22:40","Cache hits":11798,"Cache misses":1408,"Cache skips":3601,"Consistency checks":3284,"Cache invalidations":0},{"timestamp":"22:50","Cache hits":21112,"Cache misses":9316,"Cache skips":7268,"Consistency checks":6282,"Cache invalidations":9},{"timestamp":"23:00","Cache hits":10724,"Cache misses":1696,"Cache skips":4250,"Consistency checks":3651,"Cache invalidations":6},{"timestamp":"23:10","Cache hits":5256,"Cache misses":1963,"Cache skips":3556,"Consistency checks":3051,"Cache invalidations":1518},{"timestamp":"23:20","Cache hits":2687,"Cache misses":9,"Cache skips":2084,"Consistency checks":1892,"Cache invalidations":3},{"timestamp":"23:30","Cache hits":6099,"Cache misses":1656,"Cache skips":3391,"Consistency checks":3102,"Cache invalidations":2},{"timestamp":"23:40","Cache hits":4958,"Cache misses":3,"Cache skips":2619,"Consistency checks":2432,"Cache invalidations":5},{"timestamp":"23:50","Cache hits":5030,"Cache misses":9,"Cache skips":3240,"Consistency checks":2712,"Cache invalidations":9},{"timestamp":"00:00","Cache hits":4810,"Cache misses":7,"Cache skips":2580,"Consistency checks":2418,"Cache invalidations":3},{"timestamp":"00:10","Cache hits":7600,"Cache misses":3597,"Cache skips":4050,"Consistency checks":3733,"Cache invalidations":1746},{"timestamp":"00:20","Cache hits":4517,"Cache misses":2,"Cache skips":2659,"Consistency checks":2528,"Cache invalidations":1},{"timestamp":"00:30","Cache hits":5887,"Cache misses":1163,"Cache skips":3102,"Consistency checks":2921,"Cache invalidations":6},{"timestamp":"00:40","Cache hits":2429,"Cache misses":3,"Cache skips":1763,"Consistency checks":1674,"Cache invalidations":0},{"timestamp":"00:50","Cache hits":3879,"Cache misses":4,"Cache skips":2412,"Consistency checks":2300,"Cache invalidations":8},{"timestamp":"01:00","Cache hits":5783,"Cache misses":2385,"Cache skips":3153,"Consistency checks":2905,"Cache invalidations":0},{"timestamp":"01:10","Cache hits":9853,"Cache misses":3794,"Cache skips":4465,"Consistency checks":3969,"Cache invalidations":1248},{"timestamp":"01:20","Cache hits":5323,"Cache misses":2,"Cache skips":2594,"Consistency checks":2288,"Cache invalidations":7},{"timestamp":"01:30","Cache hits":7838,"Cache misses":1777,"Cache skips":3404,"Consistency checks":3114,"Cache invalidations":2},{"timestamp":"01:40","Cache hits":5644,"Cache misses":8,"Cache skips":2749,"Consistency checks":2594,"Cache invalidations":1810},{"timestamp":"01:50","Cache hits":7318,"Cache misses":2485,"Cache skips":3407,"Consistency checks":3223,"Cache invalidations":44927},{"timestamp":"02:00","Cache hits":8268,"Cache misses":1,"Cache skips":3617,"Consistency checks":3172,"Cache invalidations":24851},{"timestamp":"02:10","Cache hits":7494,"Cache misses":1350,"Cache skips":3265,"Consistency checks":2955,"Cache invalidations":18628},{"timestamp":"02:20","Cache hits":9713,"Cache misses":1537,"Cache skips":3526,"Consistency checks":3259,"Cache invalidations":2},{"timestamp":"02:30","Cache hits":12049,"Cache misses":2495,"Cache skips":4389,"Consistency checks":3966,"Cache invalidations":9},{"timestamp":"02:40","Cache hits":8282,"Cache misses":1043,"Cache skips":2947,"Consistency checks":2769,"Cache invalidations":1},{"timestamp":"02:50","Cache hits":5426,"Cache misses":9,"Cache skips":2708,"Consistency checks":2576,"Cache invalidations":3},{"timestamp":"03:00","Cache hits":5494,"Cache misses":6,"Cache skips":2452,"Consistency checks":2283,"Cache invalidations":5},{"timestamp":"03:10","Cache hits":5944,"Cache misses":1385,"Cache skips":3009,"Consistency checks":2827,"Cache invalidations":1095},{"timestamp":"03:20","Cache hits":7250,"Cache misses":3829,"Cache skips":2795,"Consistency checks":2619,"Cache invalidations":9},{"timestamp":"03:30","Cache hits":6906,"Cache misses":2467,"Cache skips":2962,"Consistency checks":2815,"Cache invalidations":1440},{"timestamp":"03:40","Cache hits":6181,"Cache misses":1295,"Cache skips":2715,"Consistency checks":2506,"Cache invalidations":1154},{"timestamp":"03:50","Cache hits":8421,"Cache misses":1814,"Cache skips":3397,"Consistency checks":3139,"Cache invalidations":1193},{"timestamp":"04:00","Cache hits":9608,"Cache misses":2866,"Cache skips":3780,"Consistency checks":3436,"Cache invalidations":3998},{"timestamp":"04:10","Cache hits":8334,"Cache misses":2419,"Cache skips":3426,"Consistency checks":3084,"Cache invalidations":1110},{"timestamp":"04:20","Cache hits":3134,"Cache misses":4,"Cache skips":1923,"Consistency checks":1633,"Cache invalidations":5},{"timestamp":"04:30","Cache hits":4282,"Cache misses":1185,"Cache skips":2305,"Consistency checks":2203,"Cache invalidations":0},{"timestamp":"04:40","Cache hits":3050,"Cache misses":5,"Cache skips":1882,"Consistency checks":1811,"Cache invalidations":5},{"timestamp":"04:50","Cache hits":5588,"Cache misses":1580,"Cache skips":2974,"Consistency checks":2817,"Cache invalidations":8},{"timestamp":"05:00","Cache hits":10101,"Cache misses":2988,"Cache skips":3625,"Consistency checks":3216,"Cache invalidations":11751},{"timestamp":"05:10","Cache hits":5228,"Cache misses":1185,"Cache skips":2538,"Consistency checks":2473,"Cache invalidations":1},{"timestamp":"05:20","Cache hits":4828,"Cache misses":0,"Cache skips":1938,"Consistency checks":1879,"Cache invalidations":2},{"timestamp":"05:30","Cache hits":10280,"Cache misses":5401,"Cache skips":4119,"Consistency checks":3953,"Cache invalidations":1342},{"timestamp":"05:40","Cache hits":7871,"Cache misses":2991,"Cache skips":2855,"Consistency checks":2711,"Cache invalidations":1802},{"timestamp":"05:50","Cache hits":5574,"Cache misses":1344,"Cache skips":2882,"Consistency checks":2764,"Cache invalidations":7},{"timestamp":"06:00","Cache hits":10942,"Cache misses":2156,"Cache skips":3370,"Consistency checks":3061,"Cache invalidations":1216},{"timestamp":"06:10","Cache hits":9673,"Cache misses":4675,"Cache skips":6014,"Consistency checks":4671,"Cache invalidations":1697},{"timestamp":"06:20","Cache hits":9113,"Cache misses":8181,"Cache skips":4750,"Consistency checks":3573,"Cache invalidations":4},{"timestamp":"06:30","Cache hits":7943,"Cache misses":5299,"Cache skips":3978,"Consistency checks":3505,"Cache invalidations":3},{"timestamp":"06:40","Cache hits":9647,"Cache misses":2641,"Cache skips":4124,"Consistency checks":3832,"Cache invalidations":6},{"timestamp":"06:50","Cache hits":17573,"Cache misses":8098,"Cache skips":6991,"Consistency checks":6359,"Cache invalidations":1216},{"timestamp":"07:00","Cache hits":13406,"Cache misses":4881,"Cache skips":6314,"Consistency checks":5278,"Cache invalidations":1215},{"timestamp":"07:10","Cache hits":13554,"Cache misses":6336,"Cache skips":6664,"Consistency checks":5438,"Cache invalidations":1192},{"timestamp":"07:20","Cache hits":11601,"Cache misses":3067,"Cache skips":5249,"Consistency checks":4381,"Cache invalidations":6},{"timestamp":"07:30","Cache hits":16106,"Cache misses":4742,"Cache skips":6539,"Consistency checks":5712,"Cache invalidations":3213},{"timestamp":"07:40","Cache hits":51802,"Cache misses":14477,"Cache skips":19304,"Consistency checks":16866,"Cache invalidations":2876},{"timestamp":"07:50","Cache hits":29884,"Cache misses":6071,"Cache skips":11220,"Consistency checks":9557,"Cache invalidations":1357},{"timestamp":"08:00","Cache hits":39064,"Cache misses":17519,"Cache skips":15751,"Consistency checks":10686,"Cache invalidations":1142},{"timestamp":"08:10","Cache hits":62113,"Cache misses":28929,"Cache skips":28316,"Consistency checks":20473,"Cache invalidations":2600},{"timestamp":"08:20","Cache hits":69518,"Cache misses":27079,"Cache skips":31819,"Consistency checks":19531,"Cache invalidations":2221},{"timestamp":"08:30","Cache hits":67370,"Cache misses":23430,"Cache skips":36287,"Consistency checks":23499,"Cache invalidations":2269},{"timestamp":"08:40","Cache hits":64360,"Cache misses":21856,"Cache skips":38335,"Consistency checks":20950,"Cache invalidations":1863},{"timestamp":"08:50","Cache hits":69015,"Cache misses":28355,"Cache skips":41964,"Consistency checks":23802,"Cache invalidations":1452},{"timestamp":"09:00","Cache hits":69018,"Cache misses":26080,"Cache skips":55617,"Consistency checks":24950,"Cache invalidations":2349},{"timestamp":"09:10","Cache hits":94231,"Cache misses":29149,"Cache skips":74283,"Consistency checks":34902,"Cache invalidations":3541},{"timestamp":"09:20","Cache hits":113032,"Cache misses":38501,"Cache skips":89933,"Consistency checks":42180,"Cache invalidations":2491},{"timestamp":"09:30","Cache hits":100393,"Cache misses":30436,"Cache skips":82138,"Consistency checks":34159,"Cache invalidations":13103},{"timestamp":"09:40","Cache hits":96481,"Cache misses":30597,"Cache skips":76298,"Consistency checks":35728,"Cache invalidations":3060},{"timestamp":"09:50","Cache hits":97522,"Cache misses":31037,"Cache skips":81880,"Consistency checks":33771,"Cache invalidations":3750},{"timestamp":"10:00","Cache hits":59861,"Cache misses":15803,"Cache skips":79805,"Consistency checks":27324,"Cache invalidations":2607},{"timestamp":"10:10","Cache hits":68975,"Cache misses":25083,"Cache skips":87553,"Consistency checks":29603,"Cache invalidations":4639},{"timestamp":"10:20","Cache hits":85449,"Cache misses":36833,"Cache skips":97540,"Consistency checks":34095,"Cache invalidations":3094},{"timestamp":"10:30","Cache hits":125518,"Cache misses":50724,"Cache skips":112209,"Consistency checks":45786,"Cache invalidations":4764},{"timestamp":"10:40","Cache hits":122290,"Cache misses":31129,"Cache skips":105490,"Consistency checks":45590,"Cache invalidations":3854},{"timestamp":"10:50","Cache hits":67484,"Cache misses":25657,"Cache skips":97057,"Consistency checks":33802,"Cache invalidations":3038},{"timestamp":"11:00","Cache hits":86797,"Cache misses":24206,"Cache skips":104991,"Consistency checks":36613,"Cache invalidations":4685},{"timestamp":"11:10","Cache hits":90544,"Cache misses":22434,"Cache skips":102989,"Consistency checks":32382,"Cache invalidations":6791},{"timestamp":"11:20","Cache hits":85558,"Cache misses":21434,"Cache skips":103703,"Consistency checks":35441,"Cache invalidations":3250},{"timestamp":"11:30","Cache hits":86842,"Cache misses":26377,"Cache skips":98007,"Consistency checks":34466,"Cache invalidations":4313},{"timestamp":"11:40","Cache hits":89002,"Cache misses":37996,"Cache skips":115183,"Consistency checks":36474,"Cache invalidations":3094},{"timestamp":"11:50","Cache hits":121529,"Cache misses":36803,"Cache skips":119837,"Consistency checks":45311,"Cache invalidations":3631},{"timestamp":"12:00","Cache hits":91040,"Cache misses":35693,"Cache skips":110153,"Consistency checks":35100,"Cache invalidations":4004},{"timestamp":"12:10","Cache hits":91481,"Cache misses":27800,"Cache skips":110537,"Consistency checks":35456,"Cache invalidations":3717},{"timestamp":"12:20","Cache hits":88144,"Cache misses":31837,"Cache skips":114016,"Consistency checks":37521,"Cache invalidations":3043},{"timestamp":"12:30","Cache hits":107530,"Cache misses":35249,"Cache skips":109642,"Consistency checks":40126,"Cache invalidations":4206},{"timestamp":"12:40","Cache hits":92436,"Cache misses":32125,"Cache skips":100182,"Consistency checks":33906,"Cache invalidations":6302},{"timestamp":"12:50","Cache hits":81829,"Cache misses":29374,"Cache skips":94248,"Consistency checks":30995,"Cache invalidations":2715},{"timestamp":"13:00","Cache hits":80448,"Cache misses":29860,"Cache skips":105860,"Consistency checks":34396,"Cache invalidations":3512},{"timestamp":"13:10","Cache hits":77298,"Cache misses":23803,"Cache skips":103373,"Consistency checks":30506,"Cache invalidations":2810},{"timestamp":"13:20","Cache hits":115612,"Cache misses":34219,"Cache skips":112426,"Consistency checks":40021,"Cache invalidations":3082},{"timestamp":"13:30","Cache hits":101737,"Cache misses":29047,"Cache skips":107691,"Consistency checks":40929,"Cache invalidations":3677},{"timestamp":"13:40","Cache hits":133219,"Cache misses":75059,"Cache skips":114723,"Consistency checks":49104,"Cache invalidations":6560},{"timestamp":"13:50","Cache hits":146898,"Cache misses":46068,"Cache skips":123825,"Consistency checks":51743,"Cache invalidations":3844},{"timestamp":"14:00","Cache hits":106722,"Cache misses":32286,"Cache skips":100856,"Consistency checks":36563,"Cache invalidations":4033},{"timestamp":"14:10","Cache hits":88608,"Cache misses":24104,"Cache skips":104038,"Consistency checks":34590,"Cache invalidations":4157},{"timestamp":"14:20","Cache hits":101807,"Cache misses":25391,"Cache skips":97290,"Consistency checks":36448,"Cache invalidations":4177},{"timestamp":"14:30","Cache hits":74548,"Cache misses":22603,"Cache skips":92935,"Consistency checks":32585,"Cache invalidations":2473},{"timestamp":"14:40","Cache hits":116239,"Cache misses":37919,"Cache skips":89465,"Consistency checks":37765,"Cache invalidations":5548},{"timestamp":"14:50","Cache hits":129964,"Cache misses":54498,"Cache skips":93897,"Consistency checks":40632,"Cache invalidations":4377},{"timestamp":"15:00","Cache hits":114862,"Cache misses":45068,"Cache skips":91031,"Consistency checks":36642,"Cache invalidations":4755},{"timestamp":"15:10","Cache hits":80394,"Cache misses":28442,"Cache skips":85536,"Consistency checks":33806,"Cache invalidations":3200},{"timestamp":"15:20","Cache hits":107624,"Cache misses":39424,"Cache skips":87645,"Consistency checks":36342,"Cache invalidations":3660},{"timestamp":"15:30","Cache hits":113422,"Cache misses":43031,"Cache skips":85412,"Consistency checks":37450,"Cache invalidations":4793},{"timestamp":"15:40","Cache hits":117653,"Cache misses":32936,"Cache skips":84539,"Consistency checks":37702,"Cache invalidations":3575},{"timestamp":"15:50","Cache hits":105016,"Cache misses":39775,"Cache skips":83163,"Consistency checks":36922,"Cache invalidations":4891},{"timestamp":"16:00","Cache hits":104644,"Cache misses":39963,"Cache skips":79744,"Consistency checks":36627,"Cache invalidations":5936},{"timestamp":"16:10","Cache hits":87428,"Cache misses":29140,"Cache skips":72525,"Consistency checks":34811,"Cache invalidations":49337},{"timestamp":"16:20","Cache hits":70532,"Cache misses":17973,"Cache skips":61745,"Consistency checks":27647,"Cache invalidations":2671},{"timestamp":"16:30","Cache hits":74560,"Cache misses":23371,"Cache skips":61584,"Consistency checks":26709,"Cache invalidations":3161},{"timestamp":"16:40","Cache hits":88352,"Cache misses":31202,"Cache skips":60488,"Consistency checks":32449,"Cache invalidations":3230},{"timestamp":"16:50","Cache hits":70167,"Cache misses":20602,"Cache skips":55862,"Consistency checks":26944,"Cache invalidations":4673},{"timestamp":"17:00","Cache hits":84036,"Cache misses":25504,"Cache skips":53893,"Consistency checks":28358,"Cache invalidations":3209},{"timestamp":"17:10","Cache hits":75883,"Cache misses":22751,"Cache skips":49255,"Consistency checks":25379,"Cache invalidations":6318},{"timestamp":"17:20","Cache hits":112062,"Cache misses":37645,"Cache skips":56438,"Consistency checks":32387,"Cache invalidations":7002},{"timestamp":"17:30","Cache hits":83740,"Cache misses":31707,"Cache skips":44583,"Consistency checks":26040,"Cache invalidations":4470},{"timestamp":"17:40","Cache hits":94260,"Cache misses":32952,"Cache skips":41846,"Consistency checks":26260,"Cache invalidations":3259},{"timestamp":"17:50","Cache hits":64028,"Cache misses":19568,"Cache skips":33055,"Consistency checks":21488,"Cache invalidations":4528},{"timestamp":"18:00","Cache hits":86794,"Cache misses":31401,"Cache skips":39232,"Consistency checks":26846,"Cache invalidations":2934},{"timestamp":"18:10","Cache hits":40684,"Cache misses":12215,"Cache skips":20298,"Consistency checks":13825,"Cache invalidations":3331}]'),h=a(5739);class l extends s.Component{componentDidMount(){const e=c;new h(document.getElementById("cache-chart"),{type:"bar",options:{scales:{x:{stacked:!0},y:{stacked:!0}}},data:{labels:e.map((e=>e.timestamp)),datasets:[{label:"Cache hits",data:e.map((e=>e["Cache hits"]))},{label:"Cache misses",data:e.map((e=>e["Cache misses"]))},{label:"Cache skips",data:e.map((e=>e["Cache skips"]))},{label:"Consistency checks",data:e.map((e=>e["Consistency checks"]))},{label:"Cache invalidations",data:e.map((e=>e["Cache invalidations"]))}]}})}render(){return s.createElement("section",null,s.createElement("canvas",{id:"cache-chart",style:{width:"100%",height:"200px"}}))}}var m=a(8146);const p={sidebar_position:3,slug:"/caching",label:"Caching"},u="Caching",d={unversionedId:"caching",id:"caching",title:"Caching",description:"This page describes the guiding principles of the Skyline caching approach.",source:"@site/docs/caching.md",sourceDirName:".",slug:"/caching",permalink:"/docs/caching",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,slug:"/caching",label:"Caching"},sidebar:"tutorialSidebar",previous:{title:"Environment",permalink:"/docs/environment"},next:{title:"CLI",permalink:"/docs/cli"}},g={},f=[{value:"Introduction",id:"introduction",level:2},{value:"Caching strategy overview",id:"caching-strategy-overview",level:2},{value:"Code example walkthrough",id:"code-example-walkthrough",level:2},{value:"Monitoring",id:"monitoring",level:2},{value:"Sandbox",id:"sandbox",level:2}],C={toc:f},v="wrapper";function y(e){let{components:n,...a}=e;return(0,i.kt)(v,(0,t.Z)({},C,a,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"caching"},"Caching"),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"This page describes the guiding principles of the Skyline caching approach. ",(0,i.kt)("br",null),"\nThe API reference of the ",(0,i.kt)("inlineCode",{parentName:"p"},"@skyline-js/cache")," package can be found here: ",(0,i.kt)("a",{parentName:"p",href:"/docs/api-reference/cache"},"@skyline-js/cache"))),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"There are only two hard things in Computer Science: cache invalidation and managing your package.json.")),(0,i.kt)("p",null,"Good news, we are about to solve cache invalidation. Regarding your package-lock.json merge conflicts, we send our prayers and thoughts. But why is caching so difficult? Consider this simple scenario of two servers, a database and a cache:"),(0,i.kt)("br",null),(0,i.kt)("mermaid",{value:"%%{init:{'themeCSS':' .noteText { tspan { fill: white; } }; .note { fill: darkred };'}}%%\n\nsequenceDiagram\n    autonumber\n\n    participant Server 1\n    participant Cache\n    participant Server 2\n\n    Server 1->> Cache: Get user:1\n    Cache ->> Server 1: Cache miss\n    Server 1->> Server 1: Get user:1 from database\n\n    Server 2->> Server 2: Update user:1 in database\n    Server 2 ->> Cache: Write udpated user:1\n\n    Server 1 ->> Cache: Write old user:1\n\n    Note over Server 1,Server 2: Cache is inconsistent\n\n"}),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note: the diagram does not show the database as a separate column due to space constraints.")),(0,i.kt)("br",null),(0,i.kt)("p",null,"Server 1 wants to read ",(0,i.kt)("inlineCode",{parentName:"p"},"user:1")," from the cache. As the user is not cached yet, he has to fetch the user from the database. To have the user cached for the next read operation, Server 1 writes the user to the cache. In the meantime, Server 2 updates the name of ",(0,i.kt)("inlineCode",{parentName:"p"},"user:1"),". He then proceeds to write the updated user to the cache."),(0,i.kt)("p",null,"The diagram shows how an unfortunate timing of these operations can result in an inconsistent cache. Timing dependent bugs are hard to observe and reproduce and are therfore well suited to destroy the morale and sanity of one or more developers."),(0,i.kt)("p",null,"How can we protect ourselves against this scenario? A solution could be to only write to the cache if no value exists for the key. This would prevent the write operation from Server 1 to write an old value for ",(0,i.kt)("inlineCode",{parentName:"p"},"user:1")," to the cache. However, what if the write operation of Server 1 is faster than the write operation of Server 2? In this case, a value for ",(0,i.kt)("inlineCode",{parentName:"p"},"user:1")," would already exist in the cache and therefore the write operation of Server 2 would be discarded, producing an inconsistent cache again."),(0,i.kt)("p",null,"To solve this problem, we could always write to the cache after we perform an update operation, regardless of whether a value exists in the cache or not. Sounds good, but this just produces more problems. Consider this diagram where two servers update the same user in parallel:"),(0,i.kt)("mermaid",{value:"%%{init:{'themeCSS':'.note { fill: darkred }; .noteText { tspan { fill: white; } } '}}%%\nsequenceDiagram\n    autonumber\n\n    participant Server 1\n    participant Cache\n    participant Server 2\n\n    Server 1 ->> Server 1: Update user:1 in database\n    Server 2 ->> Server 2: Update user:1 in database\n    Server 2 ->> Cache: Write udpated user:1\n    Server 1 ->> Cache: Write udpated user:1\n\n    Note over Server 1,Server 2: Cache is inconsistent"}),(0,i.kt)("br",null),(0,i.kt)("p",null,"I hope that this short thought experiment clearly demonstrates the need for a caching strategy that provides consistency regardless of the order of operations that are executed on the cache. This guarantuee cannot come at the expense of the complexity of the code that needs to be written, because complex code is hard to write and even harder to test, so it will be buggy and therefore not provide a guarantuee."),(0,i.kt)("p",null,"Enter the Skyline caching framework, that solves all of these problems while still providing a simple interface to the developer - by borrowing a trick or two from theoretical computer science."),(0,i.kt)("h2",{id:"caching-strategy-overview"},"Caching strategy overview"),(0,i.kt)("p",null,"The skyline caching strategy is based on the following rules:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Writing a value to a cache key only happens if the cache key is not set yet."),(0,i.kt)("li",{parentName:"ol"},"Writing a value to a cache key only happens if the value is not stale."),(0,i.kt)("li",{parentName:"ol"},"Invalidating a cache key sets the value to ",(0,i.kt)("inlineCode",{parentName:"li"},"blocked")," for a certain amount of time."),(0,i.kt)("li",{parentName:"ol"},"A value retrieved for a cache key has to be validated regarding its structure.")),(0,i.kt)("p",null,"Following these rules, no cache inconsistencies can occurr due to timing issues. However, the cache invalidation itself still needs to be done by the developer whenever a value changes. As this is very easy to forget, we furthermore need a process in place to deal with cache inconsistencies due to missing invalidations:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Every cache read has a probability of being skipped, which is resulting in a forced cache miss. This probability should be set to 100% for a newly introduced cache."),(0,i.kt)("li",{parentName:"ol"},"A skipped cache read results in the fetching of the value from the source of truth, followed by writing the value to the cache. The write operation fetches the cached value and compares it to the value that was fetched from the source of truth to detect an inconsistency."),(0,i.kt)("li",{parentName:"ol"},"The skip probability can be reduced with increasing confidence in the feature. However, in local development, CI and testing environments it should always be 100% to catch any inconsistencies that have been (re)introduced.")),(0,i.kt)("p",null,"Finally, we need a strategy for minimizing the impact that a caching error has on our production system:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Caching has to be optional to the correct functioning of the application. If the cache throws an error, it will be identical to a cache miss for the application. Errors are always logged but catched in production - in local development, CI and testing environments always thrown."),(0,i.kt)("li",{parentName:"ol"},"A cache key consists of a namespace (e.g., ",(0,i.kt)("inlineCode",{parentName:"li"},"user"),") and a key (e.g., ",(0,i.kt)("inlineCode",{parentName:"li"},"1"),"). If a cache inconsistency is detected, the entire namespace is disabled as the inconsistency is likely due to a systematic problem with that namespace's invalidation instead of only the individual key being affected.")),(0,i.kt)("br",null),(0,i.kt)("p",null,"Let's revisit the initial diagram with these rules in mind:"),(0,i.kt)("mermaid",{value:"%%{init:{'themeCSS':'.note { fill: darkgreen }; .noteText { tspan { fill: white; } } '}}%%\n\n\nsequenceDiagram\n    autonumber\n\n    participant Server 1\n    participant Cache\n    participant Server 2\n\n    Server 1->> Cache: Get user:1\n    Cache ->> Server 1: Cache miss\n    Server 1->> Server 1: Get user:1 from database\n\n    Server 2 ->> Server 2: Update user:1 in database\n    Server 2 ->> Cache: Invalidate user:1\n\n    Server 1 --\x3e> Cache: Write old user:1\n\n    Note over Server 1,Server 2: Cache is consistent\n"}),(0,i.kt)("br",null),(0,i.kt)("p",null,"Why is the cache now consistent? Step 1 - 4 are identical, however Step 5 invalidates the cache ",(0,i.kt)("inlineCode",{parentName:"p"},"user:1"),", which sets the value of the key to ",(0,i.kt)("inlineCode",{parentName:"p"},"blocked")," for a certain amount of time (e.g., 1 second). This causes the cache write of the old value in Step 6 to be discarded."),(0,i.kt)("p",null,"You could argue: ",(0,i.kt)("em",{parentName:"p"},'"What if the time between Step 5 and Step 6 is longer than 1 second? In this case, the old value would still be written to the cache!"'),"."),(0,i.kt)("p",null,"This would be correct without the staleness check rule. A value is stale and will therefore be discarded when writing it to the cache if it has been fetched from the source of truth longer than a certain threshold amount of time (e.g., 1 second). In this scenario, the ",(0,i.kt)("inlineCode",{parentName:"p"},"fetchedAt")," timestamp is recorded on Step 3, before the database is queried for the user. If the time between Step 5 and Step 6 is below 1 second, the write will be discarded because the cache key still exists (with the ",(0,i.kt)("inlineCode",{parentName:"p"},"blocked")," value). If the time is above 1 second, the write will be discarded because the value has passed the stale threshold."),(0,i.kt)("p",null,"The cache inconsistencies are mitigated, let's see if the happy path of this diagram is still fullfilled: If Step 4 and 5 do not happen, the cache key ",(0,i.kt)("inlineCode",{parentName:"p"},"user:1")," never gets blocked and therefore the correct value for ",(0,i.kt)("inlineCode",{parentName:"p"},"user:1")," is written to the cache in Step 6. Nice!"),(0,i.kt)("br",null),(0,i.kt)("p",null,"Let's look at the second diagram:"),(0,i.kt)("mermaid",{value:"%%{init:{'themeCSS':'.note { fill: darkgreen }; .noteText { tspan { fill: white; } } '}}%%\nsequenceDiagram\n    autonumber\n\n    participant Server 1\n    participant Cache\n    participant Server 2\n\n    Server 1 ->> Server 1: Update user:1 in database\n    Server 2 ->> Server 2: Update user:1 in database\n    Server 2 ->> Cache: Invalidate user:1\n    Server 1 ->> Cache: Invalidate user:1\n\n    Note over Server 1,Server 2: Cache is inconsistent"}),(0,i.kt)("br",null),(0,i.kt)("p",null,"This one is easy. The cache just gets invalidated twice, so it is obviously not inconsistent. However, an important detail here is that the second invalidation has to reset the TTL (time-to-live) of the ",(0,i.kt)("inlineCode",{parentName:"p"},"blocked")," value for ",(0,i.kt)("inlineCode",{parentName:"p"},"user:1")," to its configured value, otherwise the cache key's ",(0,i.kt)("inlineCode",{parentName:"p"},"blocked")," value could expire to soon and a late write operation as depicted in the first diagram could mess up our cache afterall."),(0,i.kt)("p",null,"To summarize, we leverage the asymmetry of a cache key being read (a lot) and a cache key being invalidated (not so often) by blocking a cache key for some time on invalidation. While we loose using the cache during this time, we gain the guarantee of a consistent cache for the rest of cache value's lifetime. Quite a bargain if you ask me! If a cache key gets invalidated frequently, we would not be able to use the cache. However, in this case caching might be the wrong approach anyways as caching is most useful for values that do not change too often."),(0,i.kt)("h2",{id:"code-example-walkthrough"},"Code example walkthrough"),(0,i.kt)("p",null,"I will demonstrate the Skyline caching strategy based on the following scenario: You want to build a NestJS web application server that stores its data in a relational database and uses Redis for caching. Your application has a dedicated data-access layer, which abstracts away the communication with the database. This is done via repositories, which offer methods to perform SQL operations on a specific database table (or multiple depending on the use-case). The database schema and therefore the SQL query structure is hidden from the consumer of the repository. The repository implements a read-through caching strategy:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Retrieve the requested value from the cache."),(0,i.kt)("li",{parentName:"ol"},"If the value could be retrieved from the cache, return it."),(0,i.kt)("li",{parentName:"ol"},"If the value is not present, retrieve the value from the database, write it to the cache and then return it.")),(0,i.kt)("p",null,"We start with such a repository for the ",(0,i.kt)("inlineCode",{parentName:"p"},"user")," entity:"),(0,i.kt)(r.Z,{path:"apps/example-cache-nestjs-minimal/src/app/",order:"user.repository.ts, user.entity.ts, user.interface.ts, user.utils.ts, user.controller.ts, database-cache.service.ts",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"user.repository",label:"user.repository.ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { Injectable } from '@nestjs/common';\nimport { InjectDataSource } from '@nestjs/typeorm';\nimport { DataSource, EntityNotFoundError } from 'typeorm';\nimport { DatabaseCacheService } from './database-cache.service';\nimport { UserEntity } from './user.entity';\nimport { CreateUserInputValobj, UpdateUserInputValobj, UserValobj } from './user.interface';\nimport { isUserRowOrThrow, isUserRowsOrThrow } from './user.utils';\n\n@Injectable()\nexport class UserRepository {\n  constructor(\n    private readonly cache: DatabaseCacheService,\n    @InjectDataSource() private readonly dataSource: DataSource,\n  ) {}\n\n  async getUsersByIds(userIds: number[]): Promise<Array<UserValobj | undefined>> {\n    if (!userIds.length) return [];\n\n    // Check cache\n    const { values: cachedUserRows, skipped } = await this.cache.getMany(\n      'user',\n      userIds,\n      isUserRowOrThrow,\n      { skip: 0.5 },\n    );\n\n    const missingUserIds = userIds.filter(\n      (userId) => !cachedUserRows.some((row) => row?.id === userId),\n    );\n\n    // Query database for missing userIds\n    let missingRows: UserValobj[] = [];\n    if (missingUserIds.length > 0) {\n      const fetchedAt = Date.now();\n      missingRows = await this.dataSource\n        .createQueryBuilder(UserEntity, 'user')\n        .select('*')\n        .whereInIds(missingUserIds)\n        .execute();\n\n      isUserRowsOrThrow(missingRows);\n\n      // Cache missing rows\n      await this.cache.setManyIfNotExist('user', (row) => row.id, missingRows, {\n        fetchedAt,\n        validate: skipped,\n      });\n    }\n\n    const rows = [...cachedUserRows, ...missingRows];\n    return userIds.map((userId) => rows.find((user) => user?.id === userId));\n  }\n\n  async getUsersById(userId: number): Promise<UserValobj | undefined> {\n    const [user] = await this.getUsersByIds([userId]);\n    return user;\n  }\n\n  async getUsersByIdOrFail(userId: number): Promise<UserValobj> {\n    const user = await this.getUsersById(userId);\n    if (!user) throw new EntityNotFoundError(UserEntity, `User with ID ${userId} not found`);\n\n    return user;\n  }\n\n  async createUser(input: CreateUserInputValobj) {\n    const rows =\n      (\n        await this.dataSource\n          .createQueryBuilder()\n          .insert()\n          .into(UserEntity)\n          .values(input)\n          .returning('*')\n          .execute()\n      ).raw ?? [];\n\n    isUserRowsOrThrow(rows);\n    const user = rows[0];\n    return user;\n  }\n\n  async updateUser(input: UpdateUserInputValobj) {\n    // Invalidate cache\n    await this.cache.invalidate('user', input.id);\n\n    const rows =\n      (\n        await this.dataSource\n          .createQueryBuilder()\n          .update(UserEntity)\n          .set(input)\n          .where('id = :id', { id: input.id })\n          .returning('*')\n          .execute()\n      ).raw ?? [];\n\n    isUserRowsOrThrow(rows);\n    const user = rows[0];\n    return user;\n  }\n\n  async deleteUser(userId: number) {\n    // Invalidate cache\n    await this.cache.invalidate('user', userId);\n\n    await this.dataSource\n      .createQueryBuilder()\n      .delete()\n      .from(UserEntity)\n      .where('id = :id', { id: userId })\n      .execute();\n  }\n}\n"))),(0,i.kt)(o.Z,{value:"user.entity",label:"user.entity.ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';\n\n@Entity()\nexport class UserEntity {\n  @PrimaryGeneratedColumn({ type: 'integer' })\n  id!: number;\n\n  @Column({ type: 'varchar', length: 255, nullable: false })\n  name!: string;\n}\n"))),(0,i.kt)(o.Z,{value:"user.interface",label:"user.interface.ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"export interface UserValobj {\n  id: number;\n  name: string;\n}\n\nexport interface CreateUserInputValobj {\n  name: string;\n}\n\nexport interface UpdateUserInputValobj {\n  id: number;\n  name: string;\n}\n"))),(0,i.kt)(o.Z,{value:"user.utils",label:"user.utils.ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { UserValobj } from './user.interface';\n\nexport function isUserRowsOrThrow(candidates: unknown[]): asserts candidates is UserValobj[] {\n  if (!Array.isArray(candidates)) {\n    throw new Error(`Expected array, got ${typeof candidates}`);\n  }\n\n  for (const candidate of candidates) {\n    if (typeof candidate !== 'object' || candidate === null) {\n      throw new Error(`Expected object, got ${typeof candidate}`);\n    }\n\n    if (typeof (candidate as UserValobj).id !== 'number') {\n      throw new Error(`Expected number, got ${typeof (candidate as UserValobj).id}`);\n    }\n\n    if (typeof (candidate as UserValobj).name !== 'string') {\n      throw new Error(`Expected string, got ${typeof (candidate as UserValobj).name}`);\n    }\n  }\n}\n\nexport function isUserRowOrThrow(candidate: unknown): asserts candidate is UserValobj {\n  isUserRowsOrThrow([candidate]);\n}\n"))),(0,i.kt)(o.Z,{value:"user.controller",label:"user.controller.ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { Body, Controller, Delete, Get, Param, Post } from '@nestjs/common';\nimport { UserRepository } from './user.repository';\n\n@Controller()\nexport class UserController {\n  constructor(private readonly userRepo: UserRepository) {}\n\n  @Get('user/:id')\n  async getUserById(@Param() params: { id: number }) {\n    const id = Number(params.id);\n    const user = await this.userRepo.getUsersById(id);\n    return { user };\n  }\n\n  @Get('users/:ids')\n  async getUsersByIds(@Param() params: { ids: string }) {\n    const ids = params.ids.split(',').map(Number);\n    const users = await this.userRepo.getUsersByIds(ids);\n    return { users };\n  }\n\n  @Post('user')\n  async createUser(@Body() input: { name: string }) {\n    const user = await this.userRepo.createUser({ name: input.name });\n    return { user };\n  }\n\n  @Delete('user/:id')\n  async deleteUser(@Param() params: { id: number }) {\n    const id = Number(params.id);\n    await this.userRepo.deleteUser(id);\n    return { id };\n  }\n}\n"))),(0,i.kt)(o.Z,{value:"database-cache.service",label:"database-cache.service.ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { Injectable } from '@nestjs/common';\nimport { RedisCacheStorageEngine, SkylineCache } from '@skyline-js/cache';\nimport { createClient } from 'redis';\n\n@Injectable()\nexport class DatabaseCacheService extends SkylineCache {\n  constructor() {\n    const redis = createClient({ url: 'redis://skyline_redis:6379' });\n    redis.connect();\n\n    super({\n      storage: new RedisCacheStorageEngine({\n        redis,\n      }),\n      config: {},\n    });\n  }\n}\n"))),(0,i.kt)(o.Z,{value:"app.module",label:"app.module.ts",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { Module } from '@nestjs/common';\nimport { UserController } from './user.controller';\nimport { UserRepository } from './user.repository';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { UserEntity } from './user.entity';\nimport { DatabaseCacheService } from './database-cache.service';\n\n@Module({\n  imports: [\n    TypeOrmModule.forRoot({\n      type: 'postgres',\n      url: 'postgres://postgres:postgres@skyline_postgres:5432/postgres',\n      schema: 'public',\n      dropSchema: true,\n      synchronize: true,\n      entities: [UserEntity],\n    }),\n  ],\n  controllers: [UserController],\n  providers: [DatabaseCacheService, UserRepository],\n})\nexport class AppModule {}\n")))),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"getUsersByIds")," retrieves one or more users by their ID. This method should be the basic building block for most of your repositories, as many other methods such as ",(0,i.kt)("inlineCode",{parentName:"p"},"getUserById"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"getUserByIdOrFail")," etc. can be derived from it (and you are not tempted to implement a ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise.all()")," if you need to get multiple entities by ID later on...)."),(0,i.kt)("p",null,"Due to the batched API of the method, we need to adjust the read-through caching execution flow as follows:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Retrieve the values for all input IDs from the cache."),(0,i.kt)("li",{parentName:"ol"},"If some values are missing, retrieve the missing values from the database and write them to the cache."),(0,i.kt)("li",{parentName:"ol"},"For each input ID, return either the retrieved value or ",(0,i.kt)("inlineCode",{parentName:"li"},"undefined")," if the ID does not exist.")),(0,i.kt)("p",null,"This is the only read/write interaction with the cache that this repository has to implement, as all other read operations are derived from ",(0,i.kt)("inlineCode",{parentName:"p"},"getUsersByIds"),". This part was easy, and the remaining cache interactions get even easier."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"updateUser")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"deleteUser")," methods simply need to invalidate the cache key for the given user ID ",(0,i.kt)("strong",{parentName:"p"},"before")," the update/ deletion is performed on the database row. If the cache is invalidated after the database operation has finished, the cache would be in an inconsistent state as it still holds the old user value which now diverges from the database row. If other repositories change make changes to the user table, they need to invalidate the respective cache keys as well. One of the main advantages of the invalidation approach instead of writing the updated value to the cache is that the method performing the update of the entity does not need to know how all the new values of the affected cache keys have to look like (which can be complex derivations or aggregates). This turns out to be very useful for larger applications."),(0,i.kt)("h2",{id:"monitoring"},"Monitoring"),(0,i.kt)("p",null,"While the SkylineJS caching approach gives developers an easy to use caching pattern that prevents many of the common caching bug sources, the invalidation of caches is still an issue. It is very easy to forget invalidating all caches that are affected by modifying some data inside the primary data storage. As it is a certainty that developers will forget to invalidate certain caches and this code will find its way into production, we need a monitoring strategy in place to make these cache inconsistencies visible and actionable. A simple chart like the one above can be created using the caching statistics features of the ",(0,i.kt)("inlineCode",{parentName:"p"},"@skyline-js/cache")," library:"),(0,i.kt)("br",null),(0,i.kt)(l,{mdxType:"CachingChart"}),(0,i.kt)("br",null),(0,i.kt)("br",null),"The bar chart shows how many cache hits, cache misses, cache skips, cache consistency checks and cache invalidations have been performed during each 10 minute interval. The example data show a healthy caching behavior regarding the distribution of the different event types. If you have much more cache misses than cache hits this might be worth investigating. Same goes for a significant difference in the number of cache skips and cache consistency checks, as those should go hand-in-hand and have therefore comparable numbers.",(0,i.kt)("p",null,"To collect the data for such a chart, you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"cache.getStatistics")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"cache.resetStatistics")," methods. These are intentionally generic so you can choose your own way of implementing the periodic collection and resetting of the cache statistics e.g., using ",(0,i.kt)("inlineCode",{parentName:"p"},"setInterval")," or the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.nestjs.com/techniques/task-scheduling"},"@nestjs/schedule")," package:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { SkylineCache } from '@skyline-js/cache';\n\nconst cache = new SkylineCache();\n\n// Collect cache statistics every 10 minutes using setInterval\nsetInterval(() => {\n  const statistics = cache.getStatistics();\n  cache.resetStatistics();\n  // ... send statistics to your analytics platform (e.g., Kibana)\n}, 1000 * 60 * 10);\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { Injectable, Logger } from '@nestjs/common';\nimport { SkylineCache } from '@skyline-js/cache';\nimport { Cron } from '@nestjs/schedule';\n\n@Injectable()\nexport class CacheService extends SkylineCache {\n  // Collect cache statistics every 10 minutes using @nestjs/schedule\n  @Cron('*/10 * * * *')\n  collectCacheStatistics() {\n    const statistics = this.getStatistics();\n    this.resetStatistics();\n    // ... send statistics to your analytics platform (e.g., Kibana)\n  }\n}\n")),(0,i.kt)("h2",{id:"sandbox"},"Sandbox"),(0,i.kt)("p",null,"You can try out the ",(0,i.kt)("inlineCode",{parentName:"p"},"@skyline-js/cache")," package API and the excellent TypeScript support here:"),(0,i.kt)(m.Z,{height:"500px",mdxType:"MonacoEditor"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { SkylineCache } from '@skyline-js/cache';\n\nconst cache = new SkylineCache();\n"))))}y.isMDXComponent=!0}}]);