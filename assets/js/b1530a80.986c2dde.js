"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7107],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>u});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var c=n.createContext({}),o=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},d=function(e){var t=o(e.components);return n.createElement(c.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,l=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=o(a),m=i,u=p["".concat(c,".").concat(m)]||p[m]||h[m]||l;return a?n.createElement(u,r(r({ref:t},d),{},{components:a})):n.createElement(u,r({ref:t},d))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=a.length,r=new Array(l);r[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[p]="string"==typeof e?e:i,r[1]=s;for(var o=2;o<l;o++)r[o]=a[o];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},6366:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>o});var n=a(7462),i=(a(7294),a(3905));const l={sidebar_position:2,label:"cache",slug:"cache"},r="@skyline-js/cache",s={unversionedId:"api-reference/cache",id:"api-reference/cache",title:"@skyline-js/cache",description:"This is the API reference for the @skyline-js/cache package.",source:"@site/docs/api-reference/cache.md",sourceDirName:"api-reference",slug:"/api-reference/cache",permalink:"/docs/api-reference/cache",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,label:"cache",slug:"cache"},sidebar:"tutorialSidebar",previous:{title:"@skyline-js/env",permalink:"/docs/api-reference/env"},next:{title:"Email",permalink:"/docs/email"}},c={},o=[{value:"SkylineCache",id:"skylinecache",level:2},{value:"cache.get",id:"cacheget",level:3},{value:"cache.getMany",id:"cachegetmany",level:3},{value:"cache.setIfNotExist",id:"cachesetifnotexist",level:3},{value:"cache.setManyIfNotExist",id:"cachesetmanyifnotexist",level:3},{value:"cache.invalidate",id:"cacheinvalidate",level:3},{value:"cache.invalidateMany",id:"cacheinvalidatemany",level:3},{value:"cache.getStatistics",id:"cachegetstatistics",level:3},{value:"cache.resetStatistics",id:"cacheresetstatistics",level:3},{value:"cache.enableCacheSkipping",id:"cacheenablecacheskipping",level:3},{value:"cache.disableCacheSkipping",id:"cachedisablecacheskipping",level:3},{value:"cache.synchronizeDisabledNamespaces",id:"cachesynchronizedisablednamespaces",level:3},{value:"cache.getDisabledNamespaces",id:"cachegetdisablednamespaces",level:3},{value:"cache.setDisabledNamespaces",id:"cachesetdisablednamespaces",level:3},{value:"cache.clearDisabledNamespaces",id:"cachecleardisablednamespaces",level:3},{value:"Interfaces",id:"interfaces",level:2},{value:"CacheConfiguration",id:"cacheconfiguration",level:3},{value:"CacheStatistics",id:"cachestatistics",level:3},{value:"CacheKey",id:"cachekey",level:3}],d={toc:o},p="wrapper";function h(e){let{components:t,...a}=e;return(0,i.kt)(p,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"skyline-jscache"},(0,i.kt)("inlineCode",{parentName:"h1"},"@skyline-js/cache")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"This is the API reference for the ",(0,i.kt)("inlineCode",{parentName:"p"},"@skyline-js/cache")," package. ",(0,i.kt)("br",null),"\nThe guiding principles of the Skyline caching approach can be found here: ",(0,i.kt)("a",{parentName:"p",href:"/docs/caching"},"Caching Primer"),".")),(0,i.kt)("h2",{id:"skylinecache"},"SkylineCache"),(0,i.kt)("p",null,"Installation"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"npm install @skyline-js/cache\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { SkylineCache } from '@skyline-js/cache';\n\nconst cache = new SkylineCache({});\n")),(0,i.kt)("h3",{id:"cacheget"},"cache.get"),(0,i.kt)("p",null,"Get a value from the cache."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"  get<T>(\n    namespace: string,\n    key: CacheKey,\n    validator: (input: unknown) => asserts input is T,\n    opts: { skip?: number } = {}\n  ): Promise<{ value: T | undefined; skipped: boolean }>\n")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"namespace")),(0,i.kt)("td",{parentName:"tr",align:null},'The namespace of the cached value (e.g. "user").')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"key")),(0,i.kt)("td",{parentName:"tr",align:null},'The key of the cached value (e.g. the user ID: "123")')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"validator")),(0,i.kt)("td",{parentName:"tr",align:null},"A validator function to validate the cached value.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"opts.skip")),(0,i.kt)("td",{parentName:"tr",align:null},'A probability between 0 and 1 whether the cache read should be skipped. This is used to detect cache inconsistencies. If the cache read is skipped, the function artifically returns "undefined" (= cache miss). Defaults to 0 (0% of cache reads are skipped).')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"returns"),(0,i.kt)("td",{parentName:"tr",align:null},'The cached value if it exists and is valid, "undefined" otherwise.')))),(0,i.kt)("h3",{id:"cachegetmany"},"cache.getMany"),(0,i.kt)("p",null,"Get multiple values from the cache."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"getMany<T>(\n    namespace: string,\n    keys: ReadonlyArray<CacheKey>,\n    validator: (input: unknown) => asserts input is T,\n    opts: { skip?: number } = {}\n  ): Promise<{ values: Array<T | undefined>; skipped: boolean }>\n")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"namespace")),(0,i.kt)("td",{parentName:"tr",align:null},'The namespace of the cached values (e.g. "user").')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"keys")),(0,i.kt)("td",{parentName:"tr",align:null},"The keys of the cached values (e.g. the user IDs: ",'["123", "456"]',")")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"validator")),(0,i.kt)("td",{parentName:"tr",align:null},"A validator function to validate each cached value.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"opts.skip")),(0,i.kt)("td",{parentName:"tr",align:null},'A probability between 0 and 1 whether the cache read should be skipped. This is used to detect cache inconsistencies. If the cache read is skipped, the function artifically returns "undefined" (= cache miss). Defaults to 0 (0% of cache reads are skipped).')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"returns"),(0,i.kt)("td",{parentName:"tr",align:null},'An array containing the cached values if they exist and are valid, "undefined" otherwise. The order of the array is the same as the order of the input keys. The length of the array is the same as the length of the input keys.')))),(0,i.kt)("h3",{id:"cachesetifnotexist"},"cache.setIfNotExist"),(0,i.kt)("p",null,"Set a cache value in the cache if it does not already exist. This operation does nothing if the value already exists or is blocked."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"setIfNotExist<T>(\n    namespace: string,\n    keyFunc: (input: T) => CacheKey,\n    value: T,\n    {\n      fetchedAt,\n      expiresIn,\n      ...opts\n    }: { fetchedAt: number; expiresIn?: number; validate?: boolean }\n  ): Promise<void>\n")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"namespace")),(0,i.kt)("td",{parentName:"tr",align:null},'The namespace of the cached value (e.g. "user").')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"keyFunc")),(0,i.kt)("td",{parentName:"tr",align:null},'A function to calculate the key of the cached value (e.g. the user ID: "123").')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"value")),(0,i.kt)("td",{parentName:"tr",align:null},"The value to cache.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"opts.fetchedAt")),(0,i.kt)("td",{parentName:"tr",align:null},"The timestamp when the value was fetched from the source. Used to determine if the value is stale (time difference is above the stale threshold). Timestamp is in UNIX milliseconds.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"opts.expiresIn")),(0,i.kt)("td",{parentName:"tr",align:null},"The expiration of the cached value in milliseconds.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"opts.validate")),(0,i.kt)("td",{parentName:"tr",align:null},"Whether the cache value should be validated. This is used to detect cache inconsistencies. Defaults to false (no cache values are validated).")))),(0,i.kt)("h3",{id:"cachesetmanyifnotexist"},"cache.setManyIfNotExist"),(0,i.kt)("p",null,"Set multiple cache values in the cache if they do not already exist."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"setManyIfNotExist<T>(\n    namespace: string,\n    keyFunc: (input: T) => CacheKey,\n    values: T[],\n    {\n      fetchedAt,\n      expiresIn,\n      ...opts\n    }: { fetchedAt: number; expiresIn?: number; validate?: boolean }\n  ): Promise<void>\n")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"namespace")),(0,i.kt)("td",{parentName:"tr",align:null},'The namespace of the cached values (e.g. "user").')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"keyFunc")),(0,i.kt)("td",{parentName:"tr",align:null},'A function to calculate the key of the cached value (e.g. the user ID: "123").')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"value")),(0,i.kt)("td",{parentName:"tr",align:null},"The values to cache.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"opts.fetchedAt")),(0,i.kt)("td",{parentName:"tr",align:null},"The timestamp when the value was fetched from the source. Used to determine if the value is stale (time difference is above the stale threshold). Timestamp is in UNIX milliseconds.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"opts.expiresIn")),(0,i.kt)("td",{parentName:"tr",align:null},"The expiration of the cached value in milliseconds.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"opts.validate")),(0,i.kt)("td",{parentName:"tr",align:null},"Whether the cache value should be validated. This is used to detect cache inconsistencies. Defaults to false (no cache values are validated).")))),(0,i.kt)("h3",{id:"cacheinvalidate"},"cache.invalidate"),(0,i.kt)("p",null,"Invalidate a cache value in the cache. Blocks the key for a short period of time to avoid timing bugs."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"invalidate(\n    namespace: string,\n    key: CacheKey,\n    { expiresIn }: { expiresIn?: number } = {}\n  ): Promise<void>\n")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"namespace")),(0,i.kt)("td",{parentName:"tr",align:null},'The namespace of the cached value (e.g. "user").')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"key")),(0,i.kt)("td",{parentName:"tr",align:null},'The key of the cached value (e.g. the user ID: "123").')),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"opts.expiresIn")),(0,i.kt)("td",{parentName:"tr",align:null},"The expiration of the blocked state in milliseconds.")))),(0,i.kt)("h3",{id:"cacheinvalidatemany"},"cache.invalidateMany"),(0,i.kt)("p",null,"Invalidate multiple cache values in the cache. Blocks each key for a short period of time to avoid timing bugs."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"invalidateMany(\n    keys: ReadonlyArray<{ namespace: string; key: CacheKey }>,\n    { expiresIn }: { expiresIn?: number } = {}\n  ): Promise<void>\n")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"keys")),(0,i.kt)("td",{parentName:"tr",align:null},"Array of namespace and key pairs to invalidate.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"opts.expiresIn")),(0,i.kt)("td",{parentName:"tr",align:null},"The expiration of the blocked state in milliseconds.")))),(0,i.kt)("h3",{id:"cachegetstatistics"},"cache.getStatistics"),(0,i.kt)("p",null,"Get caching statistics."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"getStatistics(): CacheStatistics\n")),(0,i.kt)("h3",{id:"cacheresetstatistics"},"cache.resetStatistics"),(0,i.kt)("p",null,"Reset caching statistics."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"resetStatistics(): void\n")),(0,i.kt)("h3",{id:"cacheenablecacheskipping"},"cache.enableCacheSkipping"),(0,i.kt)("p",null,"Enables the cache skipping feature. This restore the default behavior of cache skips.\nThis function only needs to be called if cache skips have been disabled in the first place."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"enableCacheSkipping(): void\n")),(0,i.kt)("h3",{id:"cachedisablecacheskipping"},"cache.disableCacheSkipping"),(0,i.kt)("p",null,"Disable the cache skipping feature.\nThis is useful for local development to see how the application behaves with full cache hits.\nThis is equivalent to setting skip: 0 for all cache read operations.\nThis option takes precedence over forceCacheSkips."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"disableCacheSkipping(): void\n")),(0,i.kt)("h3",{id:"cachesynchronizedisablednamespaces"},"cache.synchronizeDisabledNamespaces"),(0,i.kt)("p",null,"Synchronize the disabled namespaces.\nThis function is periodically called to synchronize the disabled namespaces from storage."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"synchronizeDisabledNamespaces(): Promise<void>\n")),(0,i.kt)("h3",{id:"cachegetdisablednamespaces"},"cache.getDisabledNamespaces"),(0,i.kt)("p",null,"Get the disabled namespaces.\nThe namespaces are periodically synchronized from storage.\nTherefore, only the namespaces that have been synchronized are returned."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"getDisabledNamespaces(): string[]\n")),(0,i.kt)("h3",{id:"cachesetdisablednamespaces"},"cache.setDisabledNamespaces"),(0,i.kt)("p",null,"Set disabled namespaces.\nUse this method if you want to manually handle namespace disabling."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"setDisabledNamespaces(...namespaces: string[]): void\n")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"namespaces")),(0,i.kt)("td",{parentName:"tr",align:null},"The namespaces to disable.")))),(0,i.kt)("h3",{id:"cachecleardisablednamespaces"},"cache.clearDisabledNamespaces"),(0,i.kt)("p",null,"Remove all disabled namespaces.\nUse this method if you want to manually handle namespace disabling."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"clearDisabledNamespaces(): void\n")),(0,i.kt)("br",null),(0,i.kt)("h2",{id:"interfaces"},"Interfaces"),(0,i.kt)("h3",{id:"cacheconfiguration"},"CacheConfiguration"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'path="packages/cache/src/lib/interface/cache-configuration.interface.ts" skipLines="2" remove="export "',path:'"packages/cache/src/lib/interface/cache-configuration.interface.ts"',skipLines:'"2"',remove:'"export','"':!0},'interface CacheConfiguration {\n  /**\n   * The prefix for all keys of this cache instance.\n   * Defaults to "cache"\n   */\n  cachePrefix: string;\n\n  /**\n   * Optional version for the cache. This can be used to invalidate the cache when the data structure has changed.\n   * Defaults to "undefined"\n   */\n  cacheVersion?: string;\n\n  /**\n   * Whether to force cache skips. This is useful for local development and CI environments to validate every cache.\n   * Defaults to "false"\n   */\n  forceCacheSkips: boolean;\n\n  /**\n   * Default expiration time in ms for cache entries.\n   * Defaults to 24 hours\n   */\n  defaultCacheExpirationMs: number;\n\n  /**\n   * Threshold in ms to consider data stale, causing the data to be discarded instead of writing it to the cache.\n   * Defaults to 2 seconds\n   */\n  staleThresholdMs: number;\n\n  // Disabling namespaces\n  /**\n   * Whether to disable namespaces on cache inconsistency.\n   * Defaults to "false"\n   */\n  disableNamespaces: boolean;\n\n  /**\n   * The prefix for the key to store disabled namespaces information in storage.\n   * Defaults to "disabled-namespaces"\n   */\n  disabledNamespacesKeyPrefix: string;\n\n  /**\n   * The interval in ms to check synchronize disabled namespaces from storage.\n   * Defaults to 30 seconds\n   */\n  disabledNamespacesSyncIntervalMs: number;\n\n  /**\n   * The expiration time in ms for disabling a namespace.\n   * Defaults to 24 hours\n   */\n  disabledNamespaceExpirationMs: number;\n\n  // Blocking keys\n  /**\n   * The value written to a key to block it.\n   * Defaults to "blocked"\n   */\n  cacheKeyBlockedValue: string;\n\n  /**\n   * The expiration time in ms for blocking a key.\n   * Defaults to 10 seconds\n   */\n  blockedKeyExpirationMs: number;\n\n  // Error handling\n  /**\n   * Whether to throw if an error occurrs.\n   * Defaults to "false"\n   */\n  throwOnError: boolean;\n\n  // Logging\n  /**\n   * Whether logging is enabled.\n   * Defaults to "true"\n   */\n  loggingEnabled: boolean;\n\n  /**\n   * The log levels to log.\n   * Defaults to all available log levels\n   */\n  logLevels: CacheLogLevel[];\n\n  // Random\n  /**\n   * The seed for the random number generator\n   * Defaults to "cache-rnd-seed"\n   */\n  randomGeneratorSeed: string;\n}\n')),(0,i.kt)("h3",{id:"cachestatistics"},"CacheStatistics"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'path="packages/cache/src/lib/interface/cache-statistics.interface.ts" remove="export "',path:'"packages/cache/src/lib/interface/cache-statistics.interface.ts"',remove:'"export','"':!0},"interface CacheStatistics {\n  /** Number of cache hits */\n  numCacheHits: number;\n\n  /** Number of cache misses */\n  numCacheMisses: number;\n\n  /** Number of cache skips */\n  numCacheSkips: number;\n\n  /** Number of cache skips due to disabled namespaces */\n  numCacheDisabledNamespaceSkips: number;\n\n  /** Number of cache invalidations */\n  numCacheInvalidations: number;\n\n  /** Number of cache consistency checks */\n  numCacheConsistencyChecks: number;\n\n  /** Number of cache inconsistencies */\n  numCacheInconsistencies: number;\n\n  /** Number of unknown cache errors */\n  numCacheErrors: number;\n}\n")),(0,i.kt)("h3",{id:"cachekey"},"CacheKey"),(0,i.kt)("p",null,"The type a cache key can have. ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," are explicitly excluded."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'path="packages/cache/src/lib/interface/cache-key.type.ts" remove="export "',path:'"packages/cache/src/lib/interface/cache-key.type.ts"',remove:'"export','"':!0},"type CacheKey = string | number | BigInt | boolean;\n")))}h.isMDXComponent=!0}}]);